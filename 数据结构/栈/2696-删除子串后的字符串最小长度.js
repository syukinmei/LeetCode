// 给你一个仅由 大写 英文字符组成的字符串 s 。
// 你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 "AB" 或 "CD" 子字符串。
// 通过执行操作，删除所有 "AB" 和 "CD" 子串，返回可获得的最终字符串的 最小 可能长度。
// 注意，删除子串后，重新连接出的字符串可能会产生新的 "AB" 或 "CD" 子串。

// 输入：s = "ABFCACDB"
// 输出：2
// 解释：你可以执行下述操作：
// - 从 "ABFCACDB" 中删除子串 "AB"，得到 s = "FCACDB" 。
// - 从 "FCACDB" 中删除子串 "CD"，得到 s = "FCAB" 。
// - 从 "FCAB" 中删除子串 "AB"，得到 s = "FC" 。
// 最终字符串的长度为 2 。
// 可以证明 2 是可获得的最小长度。

// 输入：s = "ACBBD"
// 输出：5
// 解释：无法执行操作，字符串长度不变。

// 方法一：栈
// 我们可以使用一个栈来模拟删除 "AB" 和 "CD" 子串的过程，每当遇到 "AB" 或 "CD"，就从栈中弹出一个元素，表示删除了一个子串。最终，栈的长度即为可获得的最终字符串的最小长度。
// 具体的：
// 我们遍历字符串 s 中的每个字符，如果当前字符与栈顶字符能够组成 "AB" 或 "CD" 子串，就弹出栈顶元素；否则，将当前字符入栈。
// 最终，栈即使删除对子后的字符数组，其长度即为可获得的最终字符串的最小长度。
/**
 * @param {string} s
 * @return {number}
 */
var minLength = function (s) {
    // 定义对子关系映射表
    const pairs = new Map([
        ["B", "A"],
        ["D", "C"],
    ]);

    const stack = []; // 栈，用于存储删除对子后的字符数组。

    for (const ch of s) {
        // 如果当前字符与栈顶字符组成匹配关系 ("AB" 或 "CD" 子串) ，则弹出栈顶元素表示删除子串。
        if (pairs.has(ch) && stack[stack.length - 1] === pairs.get(ch)) {
            stack.pop();
        } else {
            // 否则将当前字符推入栈中
            stack.push(ch);
        }
    }

    // 栈的长度即为可获得的最终字符串的最小长度
    return stack.length;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度，需要遍历一次字符串。
// 空间复杂度：O(n)，n 为字符串 s 的长度，为栈的空间开销，最坏情况字符串完全无法形成对子，需要将其全部入栈。
