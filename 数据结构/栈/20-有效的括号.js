// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

// 有效字符串需满足：

// 1.左括号必须用相同类型的右括号闭合。
// 2.左括号必须以正确的顺序闭合。
// 3.每个右括号都有一个对应的相同类型的左括号。

// 输入：s = "()"
// 输出：true

// 输入：s = "()[]{}"
// 输出：true

// 输入：s = "(]"
// 输出：false

// 提示：
// 1 <= s.length <= 104
// s 仅由括号 '()[]{}' 组成

// 方法一：栈
// 思考过程：
// 判断括号的有效性可以使用「栈」这一数据结构来解决。当我们遇到右括号时，我们需要找到最近的左括号，而栈的“先进后出”特性恰好符合这个需求。
// 使用映射关系来判断括号是否匹配。我们可以使用一个映射表 Map，将每个右括号映射到其对应的左括号。这样，当我们遇到右括号时，可以直接从映射中取得对应的左括号进行匹配。

// 具体的：
// 使用了一个栈（stack）来存储左括号。
// 遍历字符串 s ，遇到左括号时将其推入栈中。
// 遇到右括号时检查是否与栈顶的左括号匹配。如果匹配，则将栈顶的左括号弹出，继续遍历；如果不匹配，则说明括号不合法。最终，如果字符串遍历完毕后，栈为空，则括号是有效的。
// 最终查看栈中是否还有未完成匹配的左括号，如果有则无效。
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
    // 括号字符串不成对，直接返回 false
    if (s.length % 2 !== 0) return false;

    // 定义括号关系映射表
    const pairs = new Map([
        [")", "("],
        ["}", "{"],
        ["]", "["],
    ]);

    const stack = []; // 栈

    for (const ch of s) {
        // 右括号判断是否匹配
        if (pairs.has(ch)) {
            // 判断栈顶是否为匹配的括号
            if (!stack.length || stack[stack.length - 1] !== pairs.get(ch)) {
                return false;
            }
            // 匹配成功出栈
            stack.pop();
        } else {
            // 左括号入栈等待被匹配
            stack.push(ch);
        }
    }
    // 查询是否完全匹配，即栈为空
    return stack.length === 0;
};
// 时间复杂度：O(n)，n 为括号字符串 s 的长度，需要遍历整个括号字符串 s 。
// 空间复杂度：O(n)，n 为括号字符串 s 的长度，为栈的空间开销，最坏情况全是左括号，需要将其全部入栈。
