// 给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。
// 对于每两个相邻的 0 ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。
// 返回修改后链表的头节点 head 。

// 0 -> 3 -> 1 -> 0 -> 4 -> 5 -> 2 -> 0
// 输入：head = [0,3,1,0,4,5,2,0]
// 输出：[4,11]
// 解释：
// 上图表示输入的链表。修改后的链表包含：
// - 标记为绿色的节点之和：3 + 1 = 4
// - 标记为红色的节点之和：4 + 5 + 2 = 11

// 0 -> 1 -> 0 -> 3 -> 0 -> 2 -> 2 -> 0
// 输入：head = [0,1,0,3,0,2,2,0]
// 输出：[1,3,4]
// 解释：
// 上图表示输入的链表。修改后的链表包含：
// - 标记为绿色的节点之和：1 = 1
// - 标记为红色的节点之和：3 = 3
// - 标记为黄色的节点之和：2 + 2 = 4

// 题目理解：
// 每个零之间的节点值需要累加，最后将累加的结果生成一个新的节点链表。
// 在输出的链表中，每个节点值是从 0 到 0 之间所有节点值的累加值，链表的结构保持原样。
// 输入：head = [0,3,1,0,4,5,2,0] 输出：[4,11]
// 解释：合并第一个 0 和第二个 0 之间的节点 3 和 1，得到 4；合并第二个 0 和第三个 0 之间的节点 4、5 和 2，得到 11。因此输出链表为 [4, 11]。

// 方法一：迭代
// 1.遍历链表，累加两个 0 之间的节点值
// 2.遇到 0 时，累加结束，将累加结果作为新节点插入到结果链表中
// 3.返回最终合并后的链表

// 具体的：
// 创建一个哨兵节点 dummy，作为新链表的头节点的前一个节点，因此我们最终要返回的是 dummy.next。使用 cur 指向链表 dummy 的尾部。变量 sum 用来记录当前节点的值之和（作为新节点的值）。
// 从链表的第二个节点开始遍历，如果当前节点的值不为 0，我们将其加到 sum 上，否则我们将 sum 加到 cur 的后面，更新 cur 为 cur 的下一个节点，并将 sum 置为 0，继续遍历下一个节点。

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var mergeNodes = function (head) {
    const dummy = new ListNode(); // 创建一个虚拟节点作为新链表的头节点的前一个节点

    let cur = dummy; // cur 指向新链表的末尾
    let sum = 0; // 累加非零节点的值

    // 跳过第一个 0 节点
    head = head.next;

    while (head !== null) {
        if (head.val !== 0) {
            // 累加非零节点的值
            sum += head.val;
        } else {
            // 遇到零节点时，将累加的结果作为新节点的值加入到结果链表
            cur.next = new ListNode(sum);
            cur = cur.next;

            sum = 0; // 重置累加值
        }
        head = head.next; // 遍历下一个节点
    }

    return dummy.next; // 返回新链表的头节点
};
// 时间复杂度：O(n)，n 为给定链表的长度，需要遍历一次链表的每一个节点。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
