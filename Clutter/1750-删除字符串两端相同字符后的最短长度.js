// 给你一个只包含字符 'a'，'b' 和 'c' 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：

//  - 1、选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。
//  - 2、选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。
//  - 3、前缀和后缀在字符串中任意位置都不能有交集。
//  - 4、前缀和后缀包含的所有字符都要相同。
//  - 5、同时删除前缀和后缀。

// 请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。


// 输入：s = "ca"
// 输出：2
// 解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。

// 输入：s = "cabaabac"
// 输出：0
// 解释：最优操作序列为：
// - 选择前缀 "c" 和后缀 "c" 并删除它们，得到 s = "abaaba" 。
// - 选择前缀 "a" 和后缀 "a" 并删除它们，得到 s = "baab" 。
// - 选择前缀 "b" 和后缀 "b" 并删除它们，得到 s = "aa" 。
// - 选择前缀 "a" 和后缀 "a" 并删除它们，得到 s = "" 。

// 输入：s = "aabccabba"
// 输出：3
// 解释：最优操作序列为：
// - 选择前缀 "aa" 和后缀 "a" 并删除它们，得到 s = "bccabb" 。
// - 选择前缀 "b" 和后缀 "bb" 并删除它们，得到 s = "cca" 。


// 双指针模拟
// 根据操作直接删除首尾相同的连续字符即可，直到首尾字符不相等或者相交停止。
// 定义 left = 0 指向开始字符，right = s.length - 1 指向最后一个字符。
// 当两个指针指向的字符相同 且 left<right 时进行指针移动。
// 取 c 字符作为当前要进行删除的字符，两个指针分别向中间移动，直到移动到与 c 字符不相等或者 left > right 指针。
// 最后返回 [left, right] 区间的长度 right - left + 1 即可。
/**
 * @param {string} s
 * @return {number}
 */
var minimumLength = function (s) {
    let left = 0, right = s.length - 1; // 定义左右指针
    while (left < right && s[left] === s[right]) {
        let c = s[left];
        while (left <= right && s[left] === c) left++;
        while (left <= right && s[right] === c) right--;
    }
    return right - left + 1;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度，我们需要遍历一次字符串 s，字符串每个元素最多只被访问一次。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
