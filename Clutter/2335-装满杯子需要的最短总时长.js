// 现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。

// 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。


// 输入：amount = [1,4,2]
// 输出：4
// 解释：下面给出一种方案：
// 第 1 秒：装满一杯冷水和一杯温水。
// 第 2 秒：装满一杯温水和一杯热水。
// 第 3 秒：装满一杯温水和一杯热水。
// 第 4 秒：装满一杯温水。
// 可以证明最少需要 4 秒才能装满所有杯子。


// 输入：amount = [5,4,4]
// 输出：7
// 解释：下面给出一种方案：
// 第 1 秒：装满一杯冷水和一杯热水。
// 第 2 秒：装满一杯冷水和一杯温水。
// 第 3 秒：装满一杯冷水和一杯温水。
// 第 4 秒：装满一杯温水和一杯热水。
// 第 5 秒：装满一杯冷水和一杯热水。
// 第 6 秒：装满一杯冷水和一杯温水。
// 第 7 秒：装满一杯热水。


// 输入：amount = [5,0,0]
// 输出：5
// 解释：每秒装满一杯冷水。


// 方法一：贪心+分类讨论
// 贪心策略，为了使装水的时长最短，最好的办法是每次装两种不同的水，这样的时长才会最短。
// 我们对不同类型杯子的数量分别记为 x, y 和 z，其中x <= y <= x，然后分类讨论。
//  - 如果 x + y <= z，那么每次装满 z 的时候，可以同时装满 x 或 y，因此总时长为 z。
//  - 如果 x + y > z，设超出部分 x+y-z 记为 t。为了让其与情况1一样可以全部两两配对。
//      若 t 为偶数，那么我们可以先将少的两种类型的水杯 x 和 y 相互匹配 t/2 次进行"内部消化"。操作之后有 x + y = z。就和情况1一样了。每次用一个 z 和 一个 x 或 y 匹配。答案就是 t/2 + z。
//      若 t 为奇数，仍先将 x 和 y 相互匹配 (t-1)/2 次进行"内部消化"。操作之后 x+y-1 = z。此时每次用一个 z 和 一个 x 或 y 匹配，剩下一杯无法匹配，那么答案就是 (t-1)/2 + z + 1。

// 分类讨论第二条中的内部消化是一定可以进行多次的，如果无法进行上诉说的次数 x 就耗尽了，说明原本 y>z，不符合假设。
/**
 * @param {number[]} amount
 * @return {number}
 */
var fillCups = function (amount) {
    amount.sort((a, b) => a - b);
    if (amount[0] + amount[1] <= amount[2]) return amount[2];

    const t = amount[0] + amount[1] - amount[2];
    return Math.floor((t + 1) / 2) + amount[2];
};


// 方法二：递归
// 当最大值大于等于其他两个最小值之和时，答案就是这个最大值。
// 当最大值小雨其他两个最小值之和时，可以先通过让这个两个小值配对，直到变成第一种情况。
var fillCups = function (amount) {
    amount.sort((a, b) => a - b);
    if (amount[0] + amount[1] <= amount[2]) return amount[2];
    amount[0]--;
    amount[1]--;
    return fillCups(amount) + 1;
};
