// 给你一个下标从 0 开始的整数数组 nums ，表示一些石块的初始位置。再给你两个长度 相等 下标从 0 开始的整数数组 moveFrom 和 moveTo 。
// 在 moveFrom.length 次操作内，你可以改变石块的位置。在第 i 次操作中，你将位置在 moveFrom[i] 的所有石块移到位置 moveTo[i] 。
// 完成这些操作后，请你按升序返回所有 有 石块的位置。

// 注意：
//  - 如果一个位置至少有一个石块，我们称这个位置 有 石块。
//  - 一个位置可能会有多个石块。

// 输入：nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
// 输出：[5,6,8,9]
// 解释：一开始，石块在位置 1,6,7,8 。
// 第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，位置 2,6,7,8 有石块。
// 第 i = 1 步操作中，我们将位置 7 处的石块移到位置 9 处，位置 2,6,8,9 有石块。
// 第 i = 2 步操作中，我们将位置 2 处的石块移到位置 5 处，位置 5,6,8,9 有石块。
// 最后，至少有一个石块的位置为 [5,6,8,9] 。

// 输入：nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
// 输出：[2]
// 解释：一开始，石块在位置 [1,1,3,3] 。
// 第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，有石块的位置为 [2,2,3,3] 。
// 第 i = 1 步操作中，我们将位置 3 处的石块移到位置 2 处，有石块的位置为 [2,2,2,2] 。
// 由于 2 是唯一有石块的位置，我们返回 [2] 。

// 提示：
// 测试数据保证在进行第 i 步操作时，moveFrom[i] 处至少有一个石块。

// 方法一：哈希集合
// 石头位置有重复可能，哈希集合可以去重，因此可以用一个哈希集合 set 来记录有石头的坐标，然后根据 moveFrom 和 moveTo 更新 set，最后遍历 set，将其从小到大排序返回即可。
// 具体的：
//  1. 初始化哈希集合，把所有 nums[i] 加到一个哈希集合中。
//  2. 模拟搬运，遍历 moveFrom 和 moveTo，先把 moveFrom[i] 从哈希集合中去掉，然后把 moveTo[i] 加入哈希集合。
//  3. 返回答案数组，取出哈希集合中的元素，从小到大排序后返回。
/**
 * @param {number[]} nums
 * @param {number[]} moveFrom
 * @param {number[]} moveTo
 * @return {number[]}
 */
var relocateMarbles = function (nums, moveFrom, moveTo) {
    // 维护有石头的位置，初始加入 nums 中出现的坐标
    const set = new Set(nums);

    // 模拟搬运
    for (let i = 0; i < moveFrom.length; i++) {
        set.delete(moveFrom[i]);
        set.add(moveTo[i]);
    }

    // 返回答案数组，对最终有位置的石头进行排序
    const ans = Array.from(set);
    ans.sort((a, b) => a - b);
    return ans;
};
// 时间复杂度：O(nlogn + m)，n 为 nums 的长度，m 为 moveFrom 的长度。遍历哈希集合需要 O(n) 的时间，排序需要 O(nlogn) 的时间，遍历 moveFrom 需要 O(m) 的时间。时间复杂度瓶颈在于对答案的排序。
// 空间复杂度：O(n)，其中 n 为 nums 的长度。为哈希集合需要点空间开销。
