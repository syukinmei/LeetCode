// 给你一个二进制数组 nums 。
// 你可以对数组执行以下操作 任意 次（也可以 0 次）：

//  - 选择数组中 任意连续 3 个元素，并将它们 全部反转 。

// 反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。
// 请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。

// 输入：nums = [0,1,1,1,0,0]
// 输出：3
// 解释：
// 我们可以执行以下操作：
// 选择下标为 0 ，1 和 2 的元素并反转，得到 nums = [1,0,0,1,0,0] 。
// 选择下标为 1 ，2 和 3 的元素并反转，得到 nums = [1,1,1,0,0,0] 。
// 选择下标为 3 ，4 和 5 的元素并反转，得到 nums = [1,1,1,1,1,1] 。

// 示例 2：
// 输入：nums = [0,1,1,1]
// 输出：-1
// 解释：
// 无法将所有元素都变为 1 。

// 方法一：模拟
// 首先讨论一下是否需要对 i = 0 执行操作：
//  - nums[0] === 1，不需要操作，问题变成剩下 n - 1 个数的子问题。
//  - nums[0] === 0，一定要操作，问题变成剩下 n - 1 个数的子问题。
// 接下来，讨论是否需要对 i = 1执行操作，处理方式同上。
// 依次类推，直到 i = n - 3 处理完成后，还剩下 nums[n - 2] 和 nums[n - 1] 两个数，这两个数必须都为 1 ，否正无法达到所有元素均为 1 的要求。

// Q&A
// Q：为什么可以这样做？
// A：
//     1. 先操作 i 再操作 j（i !== j），和先操作 j 再操作 i，结果是一样的。所以操作顺序不影响答案。既然操作顺序无影响，我们可以从左到右操作。或者说，假设某种操作顺序是最优的，那么总是可以把这个操作顺序重排成从左到右操作。
//     2. 对于同一个 i，操作两次等于没操作，所以同一个 i 至多操作 1 次。注：操作 i 指的是反转 i, i+1, i+2 这三个位置。
//     3. 结合上述两点，既然同一个 i 至多操做一次，那么从左到右操作的过程中，遇到 1 一定不能操作，遇到 0 一定要操作。所以从左到右的操作方式有且仅有一种。
//     4. 既然操作方式是唯一的，我们只需要模拟这个过程即可。

// Q：题目要求的【最少】体现在哪里？
// A：对于同一个 i 至多操作一次，就可以做到最少的操作次数。

/**
 * @param {number[]} nums
 * @return {number}
 */
var minOperations = function (nums) {
    const n = nums.length;
    let count = 0; // 操作次数
    for (let i = 0; i < n - 2; i++) {
        // 遇到 0 进行反转操作
        if (nums[i] === 0) {
            // 使用 异或 进行反转
            nums[i + 1] ^= 1;
            nums[i + 2] ^= 1;

            // 增加一次操作次数
            count++;
        }
    }

    // 如果最后 2 个元素为 1 说明可以完成
    const isCanComplete = nums[n - 1] === 1 && nums[n - 2] === 1;

    return isCanComplete ? count : -1;
};
// 时间复杂度：O(n)，n 为给定数组 nums 的长度。需要对数组进行一次遍历，以反转所有为 0 的元素。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
