// 有两种特殊字符：
//  - 第一种字符可以用一个比特 0 来表示
//  - 第二种字符可以用两个比特(10 或 11)来表示
// 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。

// 输入: bits = [1, 0, 0]
// 输出: true
// 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。
// 所以最后一个字符是一比特字符。

// 输入: bits = [1, 1, 1, 0]
// 输出: false
// 解释: 唯一的编码方式是两比特字符和两比特字符。
// 所以最后一个字符不是一比特字符。

// 题目大意：
// 有两种字符，一种是 0，一种是 10 或者 11 。
// 给出了一个由这两种字符组成的数组，判断最后一位的数字是否一定是单个的 0。

// 方法一：模拟
// 有两种字符串，一种是 0，一种是 10 或 11。即一种长度是1，一种长度是2.
// 所以找个指针然后遍历一遍：
//  - 遇到 0 走一步；
//  - 遇到 1 走两步。
// 题目告诉了数组的最后一个元素一定是 0，所以最后如果恰好到达len-1，说明最后一个数字的长度为 1 ，也就是 0，就满足题意了。
/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function (bits) {
    let i = 0;
    for (; i < bits.length - 1; i++) {
        if (bits[i] === 1) i++; // 每次 i 都加1，如果遇到1，则在此基础上再加1
    }
    return i === bits.length - 1;
};

var isOneBitCharacter = function (bits) {
    let i = 0, n = bits.length;
    while (i < n - 1) {
        i += bits[i] + 1;
    }
    return i === n - 1;
};
// 时间复杂度：O(n)，n 为数组 bits 的长度。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
