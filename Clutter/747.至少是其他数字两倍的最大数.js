// 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。
// 请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

// 输入：nums = [3,6,1,0]
// 输出：1
// 解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。

// 输入：nums = [1,2,3,4]
// 输出：-1
// 解释：4 没有超过 3 的两倍大，所以返回 -1 。

// 输入：nums = [1]
// 输出：0
// 解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。


/**
 * @param {number[]} nums
 * @return {number}
 */

//  遍历数组分别找到数组的最大值 m1 和次大值 m2 。如果 m1>=m2*2 成立，则最大值至少是数组其余数字的两倍，此时返回最大值的下标，否则返回 -1。

// 遍历数组，找到最大值和第二大的值
// 最后判断最大值是否大于等于2倍的第二大的值
var dominantIndex = function (nums) {
    let first = -Infinity, second = -Infinity, resIndex = -1; // 分别记录最大和和第二大元素,以及最大元素下标
    // 寻找最大元素 和 第二大元素
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > first) { // 如果当前元素大于拟定的最大元素
            second = first; // 更新第二大元素
            first = nums[i]; // 更新最大元素
            resIndex = i; // 更新最大元素下标
        } else if (nums[i] > second) { // 如果当前元素大于拟定第二大元素
            second = nums[i] // 更新第二大元素，最大元素不变
        }
    }
    return first >= second * 2 ? resIndex : -1;
};
// 时间复杂度：O(n)，n为数组 nums 的长度，遍历整个数组需要O(n)。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。