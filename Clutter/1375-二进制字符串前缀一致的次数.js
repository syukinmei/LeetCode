// 给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。
// 给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。
// 二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。
// 返回二进制字符串在翻转过程中 前缀一致 的次数。

// 输入：flips = [3,2,4,1,5]
// 输出：2
// 解释：二进制字符串最开始是 "00000" 。
// 执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。
// 执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。
// 执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。
// 执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。
// 执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。
// 在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。

// 输入：flips = [4,1,2,3]
// 输出：1
// 解释：二进制字符串最开始是 "0000" 。
// 执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。
// 执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。
// 执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。
// 执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。
// 在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。

// tips:
// n == flips.length
// 1 <= n <= 5 * 104
// flips 是范围 [1, n] 中所有整数构成的一个排列

// 将题目中二进制的 0 和 1 理解为灯泡的开关，则有：
// 房间里有 n 枚灯泡，编号从 1 到 n，自左向右排成一排，最初所有的灯都是关着的。
// 在 k 时刻（k 的取值范围是 0 到 n-1），我们打开 flips[k] 这个灯。
// 灯的颜色想要变成 蓝色 就必须满足下面两个条件：
// 1、灯处于打开状态
// 2、排在它之前（左侧）的灯都处于打开状态
// 返回能够让所有开着的灯都变成蓝色的时刻数目。

// 让所有开着的灯都变成蓝色的性质是：此刻点亮的最远的灯的编号 等于 点亮的灯的数目。
// 若点亮的最远的灯的编号 大于 此刻点亮的灯的数目，则意味着在点亮的最远的灯之前存在未点亮的灯。（我点亮了编号3的灯，当时我总共点亮了2枚灯，是不是在[1,2]中还有一枚灯没点亮）。

// 方法一：记录点亮的最远的灯
/**
 * @param {number[]} flips
 * @return {number}
 */
var numTimesAllBlue = function (flips) {
  let count = 0;
  let maxReachingPoint = 0; // 维护最远到达点
  for (let i = 0; i < flips.length; i++) {
    maxReachingPoint = Math.max(maxReachingPoint, flips[i]); // 更新当前点亮灯的最远到达点
    // 判断是否符合变蓝条件，最远到达点为 编号 3，我点亮了 3 枚灯，则表示此时 [1, 3] 都被点亮，原题前缀一致符合条件。
    if (i + 1 === maxReachingPoint) count++; // 注意代码中的数组下标需要从 0 开始，而题目描述是从 1 开始。
  }
  return count;
};
// 时间复杂度：O(n)，n 为数组 flips 的长度，需要对其进行一次遍历。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。

// 方法二：数学规律（难理解）
// 由题意得，前 i 步要对 [1, i] 的所有位进行操作 等价于 flips[1: i] 要包含前 i 个数。
// 由于每个位置元素都不相同，那么数组 flips 的前 i 个数包含了 [1, i]，那么其元素和一定等于 [1, i] 的元素和。
// 通过累加元素和来判断当前操作是否满足前缀一致。
// 总结：下标和 等于 前缀和 时符合前缀一致条件。
// 以 [3, 2, 4, 1, 5] 举例：
// flips：  [3, 2, 4, 1, 5]
// preSum： [3, 5, 9, 10, 15]
// index：  [1, 2, 3, 4, 5]
// idxSum： [1, 3, 6, 10, 15]
// 在 flipx 的第 4 和 5 次操作时，满足前缀一致条件。
var numTimesAllBlue = function (flips) {
  let count = 0;
  let preSum = 0; // flips 前 i 个元素的元素和
  let idxSum = 0; // [1, i] 的和
  for (let i = 0; i < flips.length; i++) {
    preSum += flips[i]; // 累计 flips 的前缀和
    idxSum += i + 1; // 遍历数组的 i 从 0 开始，而题目定义从 1 开始，因此累加 i + 1
    if (idxSum === preSum) count++; // 两个和相等，说明 flips 前 i 个位置包含 [1, i] 所有元素，则说明前缀一致。
  }
  return count;
};
// 时间复杂度：O(n)，n 为数组 flips 的长度，需要对其进行一次遍历。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。

