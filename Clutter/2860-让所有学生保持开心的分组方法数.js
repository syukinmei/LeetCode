// 给你一个下标从 0 开始、长度为 n 的整数数组 nums ，其中 n 是班级中学生的总数。班主任希望能够在让所有学生保持开心的情况下选出一组学生：
// 如果能够满足下述两个条件之一，则认为第 i 位学生将会保持开心：

//  - 这位学生被选中，并且被选中的学生人数 严格大于 nums[i] 。
//  - 这位学生没有被选中，并且被选中的学生人数 严格小于 nums[i] 。

// 返回能够满足让所有学生保持开心的分组方法的数目。

// 输入：nums = [1,1]
// 输出：2
// 解释：
// 有两种可行的方法：
// 班主任没有选中学生。
// 班主任选中所有学生形成一组。
// 如果班主任仅选中一个学生来完成分组，那么两个学生都无法保持开心。因此，仅存在两种可行的方法。

// 输入：nums = [6,0,3,3,6,7,2,7]
// 输出：3
// 解释：
// 存在三种可行的方法：
// 班主任选中下标为 1 的学生形成一组。
// 班主任选中下标为 1、2、3、6 的学生形成一组。
// 班主任选中所有学生形成一组。

// 方法一：排序 + 模拟
// 假设恰好选了 k 个学生，则有：
//  - 所有 nums[i] < k 的学生都要选，否则不满足条件；
//  - 所有 nums[i] > k 的学生都不选，否则不满足条件；
//  - 不能出现 nums[i] = k 的学生，因为每个学生只有选和不选的两种情况。

// 这意味着「在选择学生数量固定的时候，选择方案是唯一的」。
// 如果把 nums 从小到大进行排序,唯一性可以更明显的看出：以 k 为分界线，左边的都要选，右边的都不能选。即选择排序后的 nums 数组中的前 k 个元素。
// 因此我们只需要枚举选组人数 k ∈ [0, n]，统计排序后数组 nums 中 [0, k) 的元素是否严格小于 k ，[k, n) 的元素是否严格大于 k 即可，即 nums[k - 1] < k && nums[k] > k 的方案数目。

// 具体的：
// 因为要考虑下标边界，我们可以单独枚举 k ∈ (0, n)，并判断 nums[k - 1] < k && nums[k] > k 是否成立；
// 额外处理 k = 0 一个学生不选和 k = n 所有学生都选的情况。
//  - 如果排序后数组最小值 nums[0] > 0 说明一个学生都不选的方案可行。
//  - 如果排序后数组最大值 nums[n - 1] < nums.length 说明所有学生都选的方案可行。因为题目数据保证 nums[i] < nums.length，所以这种方案一定存在，直接在返回结果 +1 即可。
/**
 * @param {number[]} nums
 * @return {number}
 */
var countWays = function (nums) {
  nums.sort((a, b) => a - b);
  const n = nums.length;
  let res = 0;
  if (nums[0] > 0) res++; // 最小值不为 0 ，则可以一个学生都不选。

  // 枚举选组人数，统计可行的方案数
  for (let k = 1; k < n; k++) {
    // 选择前 k 个人的方案可行
    if (nums[k - 1] < k && nums[k] > k) res++;
  }
  return res + 1; // 一定存在所有学生都选的方案
};
// 时间复杂度：O(nlogn)，n 为数组 nums 的长度，排序需要 O(nlogn)的时间。
// 空间复杂度：O(logn)，快排需要 O(logn)的递归栈空间。
