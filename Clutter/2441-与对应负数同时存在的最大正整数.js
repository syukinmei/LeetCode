// 给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。
// 返回正整数 k ，如果不存在这样的整数，返回 -1 。

// 输入：nums = [-1,2,-3,3]
// 输出：3
// 解释：3 是数组中唯一一个满足题目要求的 k 。

// 输入：nums = [-1,10,6,7,-7,1]
// 输出：7
// 解释：数组中存在 1 和 7 对应的负数，7 的值更大。

// 输入：nums = [-10,8,6,7,-2,-3]
// 输出：-1
// 解释：不存在满足题目要求的 k ，返回 -1 。

// 方法一：暴力解法
// 遍历数组 nums，使用整数 max_k 记录符合条件的最大整数，对于每个元素 nums[i]，如果 -nums[i] 存在于整数数组 nums 中，我们使用 nums[i] 更新 max_k 。（不需要判断 nums[i] 的正负，因为一对相反数都会被用来尝试更新 max_k）。
// 具体的：双层循环，外层循环 nums 中的每个元素，内层循环查找是否存在相反数，如果存在则更新 max_k。
// 时间复杂度；O(n^2)，n 为 整数数组 nums 的长度，我们需要进行两层循环。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。

/**
 * @param {number[]} nums
 * @return {number}
 */
// 方法二：哈希集合
// 方法一中会有重复查找，每次查看数组中是否存在相反数时并不会对已经查找过的元素进行保存记录。我们使用哈希集合对其进行保存，以空间换取时间。
// 具体的，遍历数组 nums 的同时，查看集合中是否存在其相反数，如果存在，则使用其绝对值更新 max_k。
var findMaxK = function (nums) {
  const set = new Set(); // 所有元素集合
  let max_k = -1; // 维护符合条件的最大整数
  for (const num of nums) {
    if (set.has(-num)) {
      // 存在相对数，使用其绝对值更新答案
      max_k = Math.max(max_k, Math.abs(num));
    }
    set.add(num);
  }
  return max_k;
};
// 时间复杂度：O(n)，n 为 整数数组 nums 的长度，需要对其进行一次遍历。
// 空间复杂度：O(n)，用于存储 nums 中的每个元素

// 方法三：排序+双指针
// 我们对数组 nums 进行升序排序，然后使用 r 指针从 nums 数组右端即从大到小遍历数组，同时使用 l 指针从左端小到大查找等于 -nums[r] 的元素。因为 -nums[r] 随着 r 减少儿增大，所以上一步获得的 l 值可以直接作为下一步的 l 值。
var findMaxK = function (nums) {
  // 对 nums 数组进行升序排序
  nums.sort((a, b) => a - b);
  let l = 0,
    r = nums.length - 1; // 定义左右指针
  while (l < r) {
    // l 左指针右移动 ps:此时不需要判断 l < r，因为 -nums[r] 一定在 nums[l] 右侧
    while (nums[l] < -nums[r]) {
      l++;
    }
    // 判断是否为相对数，如果是则直接返回 nums[r]。
    // 因为我们已经对nums进行了升序排序，此时nums[r]就是符合条件的最大整数
    if (nums[l] === -nums[r]) return nums[r];
    r--; // 右指针左移
  }
  return -1;
};
// 时间复杂度：O(nlogn)，n 为 整数数组 nums 的长度，排序需要 nlogn 的时间
// 空间复杂度：O(logn)，快排需要 O(logn)的递归栈空间。
