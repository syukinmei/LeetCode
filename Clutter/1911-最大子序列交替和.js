// 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

//  - 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。

// 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
// 一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

// 输入：nums = [4,2,5,3]
// 输出：7
// 解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。

// 输入：nums = [5,6,7,8]
// 输出：8
// 解释：最优子序列为 [8] ，交替和为 8 。

// 输入：nums = [6,2,1,2,4,5]
// 输出：10
// 解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。

// 方法一：动态规划
// 定义 f[i] 表示从前 i 个元素中选出的子序列，且最后一个元素为奇数下标时的最大交替和
// 定义 g[i] 表示从前 i 个元素中选出的子序列，且最后一个元素为偶数下标时的最大交替和
// 初始时 f[0] = g[0] = 0 。答案为 max(f[n], g[n])。
// 当我们考虑第 i 个元素 num[i-1] 时
//  - 如果选取该元素 且 该元素为奇数下标，那么上一个元素必须为偶数下标，且只能从前 i-1 个元素中选取，因此 f[i] = g[i-1] - nums[i-1]
//  - 如果不选取该元素，那么 f[i] = f[i-1]

//  - 如果选取该元素 且 该元素为偶数下标，那么上一个元素必须为奇数下标，且只能从前 i-1 个元素中选取，因此 g[i] = f[i-1] + nums[i-1]
//  - 如果不选取该元素，那么 g[i] = g[i-1]

// 综上所述，我们可以得到状态移动方程：
//      f[i] = max(g[i - 1] - nums[i - 1], f[i - 1]);
//      g[i] = max(f[i - 1] + nums[i - 1], g[i - 1]);

// 因为最大交替和一定不会是f[n]，因为最终选择的子序列最后一个元素一定不能是奇数下标，因为奇数下标对应减去这个这个元素的值，我们可以不选择该元素。
// 因此最终答案为 g[n]
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxAlternatingSum = function (nums) {
  const n = nums.length;
  const f = new Array(n).fill(0);
  const g = new Array(n).fill(0);
  for (let i = 1; i <= n; i++) {
    f[i] = Math.max(g[i - 1] - nums[i - 1], f[i - 1]);
    g[i] = Math.max(f[i - 1] + nums[i - 1], g[i - 1]);
  }
  return g[n];
};
// 时间复杂度：O(n)，n 为数组 nums 的长度，我们需要遍历一次数组。
// 空间复杂度：O(n)，需要两个长度为 n 的数组用于存储状态。可以使用 滚动数组 将其优化为常量的空间。
