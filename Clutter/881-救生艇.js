// 给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。
// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
// 返回 承载所有人所需的最小船数 。

// 输入：people = [1,2], limit = 3
// 输出：1
// 解释：1 艘船载 (1, 2)

// 输入：people = [3,2,2,1], limit = 3
// 输出：3
// 解释：3 艘船分别载 (1, 2), (2) 和 (3)

// 输入：people = [3,5,3,4], limit = 5
// 输出：4
// 解释：4 艘船分别载 (3), (3), (4), (5)

// tips:
// 1 <= people.length <= 5 * 10^4
// 1 <= people[i] <= limit <= 3 * 10^4

// 方法一：贪心+双指针
// 要使需要的船数尽可能的少，应当使载 2 人的船尽可能的多。即尽可能多的构造出体量之和不超过 limit 的二元组。
// 因此我们的贪心策略是：大体重的人看能不能搭上一个小体重的人。
// 极端的，最大体重的人，不能和最小体重的人凑成一对上船，如果最小体重的人都不行，那么就没有其他人行了，这是显而易见的，因此最大体重的人必须自己一条船。
// 具体的：
// 为了找到最大体重和最小体重，我们需要对数组 people 进行排序，并使用「双指针」来维护体重较轻和较重的人的边界。l 指针指向当前体重最小的人，r 指针指向当前体重最大的人。
//  - people[l] + people[r] <= limit，说明最大体重的和最小体重的人可以做一条船。此时 l 和 r 分别向中间移动，移动到体重次小和体重次大的人。
//  - 否则，说明最大体重的人无法和任何人做一条船，因此只能自己一条船，j 向中间移动，移动到体重次小的人，看看能不能带上最小体重的人。
/**
 * @param {number[]} people
 * @param {number} limit
 * @return {number}
 */
var numRescueBoats = function (people, limit) {
    people.sort((a, b) => a - b); // 体重升序排序

    let boats = 0; // 需要的船数

    let l = 0,
        r = people.length - 1; // 定义左右指针
    while (l <= r) {
        if (people[l] + people[r] <= limit) {
            // 最轻和最重的人可以同船，则移动两个指针
            l++;
            r--;
        } else {
            // 否则，只有最重的人独自乘船，移动右指针
            r--;
        }
        // 每次操作都需要一条船
        boats++;
    }
    return boats;
};
// 时间复杂度：O(nlogn)，n 为数组 people 的长度。排序需要O(nlogn)的时间。
// 空间复杂度：O(logn)，排序需要O(logn)的递归栈空间。
