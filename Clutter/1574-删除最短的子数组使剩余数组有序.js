// 给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。
// 一个子数组指的是原数组中连续的一个子序列。
// 请你返回满足题目要求的最短子数组的长度。

// 方法一：双指针
// 这道题需要做的是删除某个子数组，使得剩下的部分可以构成一个非递减数组。
// 最基本的方案是删除数组的前缀元素，使得后缀剩余元素形成非递减数组。这样做的话，我们需要一个初始指向数组 arr 尾部的指针，将其不断往前移动，直到指向的元素 arr[i] < arr[i-1] 为止，此时我们需要删除的就是该指针前面的所有元素[0, i-1]。
// 与此情况类似的，我们也可以删除数组的尾部元素。
// 但是我们不会满足于此，最佳答案可能是删除中间的某一段，例如 [1, 3, 5, 4, 6, 8]，最佳的答案是删除中间的 5 或者 4，而不是删除前缀 1, 3, 5 或者后缀 4, 6, 8。
// 那么我们可以将数组看成3部分：
// 非递减前缀   +   无序数组   +   非递减后缀
// 0 .... i     i+1 ... j-1    j ...  n-1

// 去掉无序的子数组后剩下部分为 前缀 [0, i] + 后缀 [j, n-1]，要使得这部分题意的非递减，就绪满足：
//  - 前缀本身非递减
//  - 后缀本身非递减
//  - arr[i] <= arr[j]

/**
 * @param {number[]} arr
 * @return {number}
 */
var findLengthOfShortestSubarray = function (arr) {
  const n = arr.length;
  let left = 0,
    right = n - 1; // 初始化需要删除的子数组的左右端点，为整个 arr 数组
  // 查找最长非递减前缀数组，将其尾部作为需要删除的无序数组左端点
  while (left + 1 < n && arr[left] <= arr[left + 1]) left++;

  // 此时最长非递减前缀数组就是原数组，不需要删除任何元素之间返回 0。
  if (left === n - 1) return 0;

  // 查找最长非递减后缀数组，将其头部作为需要删除的无序数组的右端点
  while (right > 0 && arr[right - 1] <= arr[right]) right--;

  // 此时有 [0, left] 为非递减前缀数组，[left+1, right-1] 无序数组，[right, n-1] 为非递减后缀数组

  if (arr[left] <= arr[right]) return right - left - 1;

  let res = Math.min(n - left - 1, right); // 初始化需要删除的子数组最短长度。

  // 寻找最短的连续
  let i = 0;
  j = right;
  while (i <= left && j < n) {
    // 找到了一组满足要求的子数组，更新答案
    if (arr[i] <= arr[j]) {
      res = Math.min(res, j - i - 1);
      i++;
    } else {
      j++;
    }
  }
  return res;
};

// 思路二：
var findLengthOfShortestSubarray = function (arr) {
  let n = arr.length;
  let j = n - 1; // 初始化最长非递减后缀数组右端点

  // 查找最长非递减后缀数组，将其头部作为需要删除的无序数组的右端点
  while (j > 0 && arr[j - 1] <= arr[j]) {
    j--;
  }

  // 此时最长非递减后缀数组的头部达到原数组的起点，则原数组就是满足非递减的，不需要删除任何元素之间返回 0。
  if (j === 0) {
    return 0;
  }
  let res = j; // 初始化需要删除的最短子数组为最长非递减后缀数组外的内容，长度为 j。

  // 查找每个前缀数组的下标 i 可匹配的最小后缀数组的下标j
  for (let i = 0; i < n; i++) {
    while (j <= n - 1 && arr[i] > arr[j]) {
      j++;
    }
    // 找到了一组满足要求的子数组，更新答案
    res = Math.min(res, j - i - 1);

    // 如果下个元素和当前元素不满足非递减条件，说明到达最长非递减前缀的边界。直接跳出循环即可
    if (i != n - 1 && arr[i + 1] < arr[i]) break;
  }
  return res; // 返回最短的无序子数组的长度
};
