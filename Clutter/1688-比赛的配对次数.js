// 给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：
//  -  如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。
//  -  如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。
// 返回在比赛中进行的配对次数，直到决出获胜队伍为止。


// 输入：n = 7
// 输出：6
// 解释：比赛详情：
// - 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。
// - 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
// - 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
// 总配对次数 = 3 + 2 + 1 = 6

// 输入：n = 14
// 输出：13
// 解释：比赛详情：
// - 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。
// - 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 
// - 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。
// - 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。
// 总配对次数 = 7 + 3 + 2 + 1 = 13

/**
 * @param {number} n
 * @return {number}
 */
// 方法一：模拟
var numberOfMatches = function (n) {
    let teams = n;
    let ans = 0; // 记录比赛中配对的场次
    while (teams > 1) { // 只剩下一个队伍 及决出了冠军队伍 结束循环
        if (teams % 2 === 0) { // 队伍数量为 偶数 可以两两配对
            ans += teams / 2; // 进行 n / 2 场比赛
            teams /= 2; // n / 2 支队伍进入下一轮
        } else { // 队伍数量为 奇数 不能两两配对
            ans += (teams - 1) / 2; // 进行 (n - 1) / 2 场比赛
            teams = (teams - 1) / 2 + 1; // (n - 1) / 2 + 1 支队伍进入下一轮
        }
    }
    return ans;
};
// 时间复杂度：O(log n)。每一轮后会有一半（向下取整）数量的队伍无法晋级，因此轮数为O(log n)。每一轮需要O(1)的时间进行计算。
// 空间复杂度：O(1)。只需要常数的空间存放若干变量。


// 方法二：数学
// 每场比赛淘汰一支，由于最后只决出一个获胜队伍，因此就有 n−1 个无法晋级的队伍，也就是会有 n−1 场比赛。
var numberOfMatches = function (n) {
    return n - 1;
};
// 时间复杂度：O(1)
// 空间复杂度：O(1)