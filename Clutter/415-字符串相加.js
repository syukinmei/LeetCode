// 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
// 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

// 输入：num1 = "11", num2 = "123"
// 输出："134"

// 输入：num1 = "456", num2 = "77"
// 输出："533"

// 输入：num1 = "0", num2 = "0"
// 输出："0"

// 方法一：模拟
// 模拟两个大整数「竖式相加」的过程。即，将两个数相同的数位对齐，从低到高逐步相加，如果当前位和超过10，则向高位进一位。
// 具体的，
//  1、对齐低位，即使用两个指针分别指向两个字符串的末尾，从后往前计算。
//  2、计算每一位，当前位的和 sum 等于 nums1、nums2 当前位的数字和再加上进位。
//  3、当前位的值等于当前位的和 sum 模 10。
//  4、当前位产生的进位值等于当前位的和 sum 除以 10 并向下取整。
//  5、如果两个数字的数位不一致，可以在指针下标处于负数的时候返回 0，等价于 「对位数较短的数字进行了补零操作」。
//  6、如果计算完所有位后，进位值不为 0 的需要进行高位补 1。
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function (num1, num2) {
  let p1 = num1.length - 1; // 指针 p1 指向 num1 的最后一位
  let p2 = num2.length - 1; // 指针 p2 指向 num2 的最后一位
  let carry = 0; // 进位
  let ans = ""; // 存储结果的字符串
  while (p1 >= 0 || p2 >= 0 || carry !== 0) {
    // 获取 nums1、nums2 当前位的数字，如果指针超出范围则为 0。
    const digit1 = p1 >= 0 ? num1.charAt(p1) - "0" : 0;
    const digit2 = p2 >= 0 ? num2.charAt(p2) - "0" : 0;
    const sum = digit1 + digit2 + carry; // 当前位的数字相加，并加上进位。
    ans = (sum % 10) + ans; // 讲当前位的数字加入到结果字符串的开头
    carry = (sum / 10) | 0; // 计算新的进位，除10向下取整，去除 n 的最低位
    // 移动指针到前一位
    p1--;
    p2--;
  }
  return ans; // 返回结果字符串
};
// 时间复杂度：O(max(n, m))，n 和 m 分别为 nums1、nums2 的长度，竖式加法的次数取决于较大数的位数。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
