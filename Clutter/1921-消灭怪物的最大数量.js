// 你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 0 开始 且长度为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：米）。
// 怪物以 恒定 的速度走向城市。给你一个长度为 n 的整数数组 speed 表示每个怪物的速度，其中 speed[i] 是第 i 个怪物的速度（单位：米/分）。
// 怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。
// 一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。
// 返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。

// 输入：dist = [1,3,4], speed = [1,1,1]
// 输出：3
// 解释：
// 第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。
// 第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。
// 第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。
// 第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。
// 所有 3 个怪物都可以被消灭。

// 输入：dist = [1,1,2,3], speed = [1,1,1,1]
// 输出：1
// 解释：
// 第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。
// 第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。
// 你只能消灭 1 个怪物。

// 输入：dist = [3,2,4], speed = [5,3,2]
// 输出：1
// 解释：
// 第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。
// 第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。
// 你只能消灭 1 个怪物。

// 方法一:贪心+排序
// 为了消灭尽可能多的怪物，我方需要坚持尽可能长的时间，因为我方每分钟都能消灭一个怪物。为了坚持更久，我方需要先消灭先来的怪物。
// 因此，贪心的思路是将怪物的到达时间排序，先消灭到达时间早的怪物。
// 我方的攻击时间序列是 [1,2,3,… ]，将我方的攻击时间序列和排序后的怪物到达时间依次进行比较，当第一次出现到达时间小于等于攻击时间，即表示怪物到达城市，我方会输掉游戏。
// 在比较时，因为我方的攻击时间为整数，因此可以将怪物到达时间向上取整，可以达到避免浮点数误差的效果。
// 如果遍历完序列都没有出现这种情况，则表示我方可以消灭全部怪物。

/**
 * @param {number[]} dist
 * @param {number[]} speed
 * @return {number}
 */
var eliminateMaximum = function (dist, speed) {
  const n = dist.length;
  const arrivalTimes = new Array(n).fill(0);
  for (let i = 0; i < n; i++) {
    arrivalTimes[i] = Math.ceil(dist[i] / speed[i]);
  }

  arrivalTimes.sort((a, b) => a - b);

  let count = 0; // 记录消灭怪物的个数
  for (let i = 0; i < n; i++) {
    if (i < arrivalTimes[i]) count++; // 在最近的怪物抵达前有发动一次攻击
    else return count;
  }
  return count;
};
// 时间复杂度：O(nlogn)，n 为怪物数量。需要对怪物抵达城市时间进行升序排序，排序需要 O(nlogn)的时间。
// 空间复杂度：O(n)，需要一个数组存储每只怪物抵达城市的时间。
