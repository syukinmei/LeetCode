// 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
// 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
// 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
// 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

// 输入：nums = [4,3,10,9,8]
// 输出：[10,9] 
// 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 

// 输入：nums = [4,4,7,6,7]
// 输出：[7,7,6] 
// 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  

// 输入：nums = [6]
// 输出：[6]

/**
 * @param {number[]} nums
 * @return {number[]}
 */
// 方法一：贪心
// 应尽量保证取出的元素尽可能的大，才能满足取出的元素尽可能的少且元素之和尽可能的大，因此我们按照从大到小的顺序依次从原始数组中取出数据，直到取出的数据之和 curr 大于数组中剩余的元素之和为止。
// 先排序，遍历数组sum，然后倒序求和，大于sum/2后，返回该元素到最后所有元素即可。
var minSubsequence = function (nums) {
    // 求nums数组之和
    const Len = nums.length;
    let sum = 0;
    for (let i = 0; i < Len; i++) {
        sum += nums[i];
    }
    const needSum = Math.floor(sum / 2); // 和需要大于needSum
    nums.sort((a, b) => b - a); // 对nums倒叙排序，每次拿最大值。
    const res = [];
    let curr = 0;
    for (let i = 0; i < Len; i++) {
        res.push(nums[i]);
        curr += nums[i];
        if (curr > needSum) break;
    }
    return res;
};
// 时间复杂度：O(nlogn)，n 为数组 nums 的长度。需要对数组进行排序，时间复杂度为O(nlogn)。
// 空间复杂度：O(logn)，n 为数组 nums 的长度。排序需要的栈空间为O(logn)。
