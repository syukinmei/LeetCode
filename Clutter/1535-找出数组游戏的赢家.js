// 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。
// 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。
// 返回赢得比赛的整数。
// 题目数据 保证 游戏存在赢家。

// 输入：arr = [2,1,3,5,4,6,7], k = 2
// 输出：5
// 解释：一起看一下本场游戏每回合的情况：

// | 回合 | 数组            | 获胜整数 | 连胜回合数 |
// | ---- | --------------- | -------- | ---------- |
// | 1    | [2,1,3,5,4,6,7] | 2        | 1          |
// | 2    | [2,1,3,5,4,6,7] | 3        | 1          |
// | 3    | [2,1,3,5,4,6,7] | 5        | 1          |
// | 4    | [2,1,3,5,4,6,7] | 5        | 2          |

// 因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。

// 输入：arr = [3,2,1], k = 10
// 输出：3
// 解释：3 将会在前 10 个回合中连续获胜。

// 输入：arr = [1,9,8,2,3,7,6,4,5], k = 7
// 输出：9

// 输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
// 输出：99

// tips：
// 2 <= arr.length <= 10^5
// 1 <= arr[i] <= 10^6
// arr 所含的整数 各不相同 。
// 1 <= k <= 10^9

// 方法一：脑筋急转弯
// 据题意，每轮比较数组前两个元素，较小的元素会移至数组的末尾，在重新遇到被移至数组末尾的元素之前，arr 中的每个元素都会被访问。
// 观察游戏执行的流程，无论每回合结果如何，下次比较一定是轮到了数组中的下一个元素和当前回合获胜的元素比较，本质上是在从左到右遍历 arr，求数组最大值（打擂台）。我们要找「首个」连续 k 回合都是最大值的数。
// 如果遍历完一次 arr 数组也没找到这样的数，那么答案就是 arr 中最大的元素 max。因为此时比它小的数都会被移到它的右边，所以后面的回合比大小都是 max 胜。
// 具体的：
// 初始化 max = arr[0]，win = 0，从 arr[1] 开始遍历数组。其中 win 用于统计 max 连续多少个回合是最大值（获胜）。
// 如果 arr[i] > max，更新 max = arr[i] 以及 win = 0
// 把 win 加一如果 win = k 就推出循环
// 遍历结束（或者中途退出循环），返回 max。

/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var getWinner = function (arr, k) {
    let max = arr[0]; // 初始获胜值为首个元素
    let win = 0; // 统计获胜次数，初始为0
    for (let i = 1; i < arr.length && win < k; i++) {
        if (arr[i] > max) {
            // 存在新的最大值
            max = arr[i];
            win = 0;
        }
        win++;
    }
    return max;
};
// 时间复杂度：O(n)，n 为数组 arr 的长度，由于题目数据保证游戏存在赢家，因此我们最多只需要遍历一次数组即可。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
