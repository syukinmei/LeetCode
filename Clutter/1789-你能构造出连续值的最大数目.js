// 给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。
// 请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。
// 你可能有多个相同值的硬币。


// 输入：coins = [1,3]
// 输出：2
// 解释：你可以得到以下这些值：
// - 0：什么都不取 []
// - 1：取 [1]
// 从 0 开始，你可以构造出 2 个连续整数。


// 输入：coins = [1,1,1,4]
// 输出：8
// 解释：你可以得到以下这些值：
// - 0：什么都不取 []
// - 1：取 [1]
// - 2：取 [1,1]
// - 3：取 [1,1,1]
// - 4：取 [4]
// - 5：取 [4,1]
// - 6：取 [4,1,1]
// - 7：取 [4,1,1,1]
// 从 0 开始，你可以构造出 8 个连续整数。


// 输入：nums = [1,4,10,3,1]
// 输出：20


/**
 * @param {number[]} coins
 * @return {number}
 */
// 方法一：贪心
// 假设数组中若干个元素可以构建出 [0, x] 范围内的所有整数，如果此时我们再多选一个元素 y，那么这些元素就可以构造出 [0,x] 以及 [y, x+y] 范围内的所有整数。
// 为了构造出连续的更多的整数，那么我们的 y 需要满足 y <= x+1。这样 y 就可以使得构成出的连续整数范围从[0, x]增加到了[0, x+y]。否则 y 不会对答案产生任何影响。
// 具体的，对数组进行生序排序，每次选择数组中未被选择的元素中最小的作为 y。如果 y<=x+1，那么就可以更新答案区间，否则剩下的更大的元素不会对答案产生任何影响，因为它们中间出现了断层。
var getMaximumConsecutive = function (coins) {
    coins.sort((a, b) => a - b); // 对数组进行生序排序
    let x = 1; // 初始时没有选择任何元素，对应区间为[0,0]元素个数为1个。
    for (let i = 0; i < coins.length; i++) {
        if (coins[i] > x) break;
        x += coins[i]; // 更新答案区间为 [0, x+y]
    }
    return x;
};
// 时间复杂度：O(nlogn)，n 为数组 coins 的长度，主要为排序所需的时间开销。
// 空间复杂度：O(logn)，快排需要 O(logn)的递归栈空间。
