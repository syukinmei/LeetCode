// 给你一个仅由 0 和 1 组成的二进制字符串 s 。
// 如果子字符串中 所有的 0 都在 1 之前 且其中 0 的数量等于 1 的数量，则认为 s 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。
// 返回  s 中最长的平衡子字符串长度。
// 子字符串是字符串中的一个连续字符序列

// 输入：s = "01000111"
// 输出：6
// 解释：最长的平衡子字符串是 "000111" ，长度为 6 。

// 输入：s = "00111"
// 输出：4
// 解释：最长的平衡子字符串是 "0011" ，长度为  4 。

// 输入：s = "111"
// 输出：0
// 解释：除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。

// 方法一：模拟
// 使用一个长度为 2 的数组 count 分别记录遇到的连续 "0" 和连续 "1" 的个数。
// 如果遇到 "0"：
//  - count[0] 自增 1 ，如果前一个字符为非 "0" 则 需要先将 count 重置，count[0] 记为 0 ，count[1] 记为 0。
// 如果遇到 "1"：
//  - 只需要将 count[1] 自增 1，此时有 "O" 可作为平衡字符串的结尾，通过 2 * min(count[0], count[1]) 更新答案。
/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestBalancedSubstring = function (s) {
  let res = 0;
  const count = [0, 0];
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "0") {
        // 出现了新的平衡字符串
      if (s[i - 1] !== "0") {
        // 重置
        count[0] = 0;
        count[1] = 0;
      }
      count[0]++;
    }
    if (s[i] === "1") {
      count[1]++;
      res = Math.max(res, 2 * Math.min(count[0], count[1]));
    }
  }
  return res;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度，只需要遍历一次字符串即可。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
