// 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
// 说明：
// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

// 输入: [2,2,1]
// 输出: 1

// 输入: [4,1,2,1,2]
// 输出: 4


// 方法一：哈希表 记录次数
// 1、遍历数组，同时建立哈希表用来记录每个数字在数组中出现的次数；
// 2、遍历哈希表，找到只出现一次的数字。

// 方法二：集合 记录数字
// 在遍历数组时记录出现过的数字；
// 如果当前数字没有出现过，则将数字记下，否则将其从集合中删去；
// 最后集合中剩下的数字就是只出现一次的数字。

// 以上两种方法时间复杂度和空间复杂度相同
// 时间复杂度：o(n)
// 空间复杂度：O(n)


// 方法三：位运算
// XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b
// 由于异或在位运算时相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。
// n ^ n === 0  且 n ^ 0 === 0 
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function (nums) {
    let res = 0;
    for (let num of nums) {
        res ^= num;
    }
    return res;
};
// 时间复杂度：O(n)，n 为数组 nums 的长度，需要对 nums 进行一次遍历。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。