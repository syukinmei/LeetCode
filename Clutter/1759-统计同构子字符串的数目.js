// 给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。
// 同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。
// 子字符串 是字符串中的一个连续字符序列。

// 输入：s = "abbcccaa"
// 输出：13
// 解释：同构子字符串如下所列：
// "a"   出现 3 次。
// "aa"  出现 1 次。
// "b"   出现 2 次。
// "bb"  出现 1 次。
// "c"   出现 3 次。
// "cc"  出现 2 次。
// "ccc" 出现 1 次。
// 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13

// 输入：s = "xy"
// 输出：2
// 解释：同构子字符串是 "x" 和 "y" 。

// 输入：s = "zzzzz"
// 输出：15


// 方法一：滑动窗口
// 根据同构字符串的定义，我们发现，同构子字符串的数量，只和字母相同的区间有关。如 `abbcccaa` ，有4个影响答案的区间，分别为 a bb ccc aa。因为对于一个组中字符串的任意子字符串都为「同构子字符串」，而一个长度为 m 的字符串的子字符串数目为 m*(m+1) / 2。那么我们计算每一个组的贡献的「同构子字符串」数目并求和即可。
// 所以使用滑动窗口的思想，维护字母相同的连续字符串，通过窗口的长度，维护并计算答案。
// Q：为什么长度为 m 的字符串，有 m*(m+1) / 2 个子串？
// A：长度为1的子串有 m 个，长度为2的子串有 m-1 个，...，长度为 m 的子串有1个，1+2+...+m = m*(m+1) / 2
/**
 * @param {string} s
 * @return {number}
 */
var countHomogenous = function (s) {
    let i = 0, j = 0;
    let ans = 0;
    const MOD = 1000000007
    while (i < s.length) {
        while (j < s.length && s[j] === s[i]) j++; // 右指针右移动，放大窗口
        let cnt = j - i; // 窗口大小
        ans += (cnt + 1) * cnt / 2; // 记录 [i,j] 窗口中同构子字符串的数目
        i = j; // 移动左指针到有右指针位置，缩小窗口
    }
    return ans % MOD;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度，我们需要对其遍历一次，维护滑动窗口，字符串 s 的每一个字符只被访问一次。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
