// 给你一个正整数 n 。n 中的每一位数字都会按下述规则分配一个符号：

//  - 最高有效位 上的数字分配到 正 号。
//  - 剩余每位上数字的符号都与其相邻数字相反。

// 返回所有数字及其对应符号的和。

// 输入：n = 521
// 输出：4
// 解释：(+5) + (-2) + (+1) = 4

// 输入：n = 111
// 输出：1
// 解释：(+1) + (-1) + (+1) = 1

// 输入：n = 886996
// 输出：0
// 解释：(+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0

// 方法一：模拟
// 根据题意，从 n 的高位开始，取每一位值，然后正负交替的相加。
// 对于一个整数 n 去获取它的每一位值的时候，从低位到高位获取会非常容易。
// 因此，我们可以对比「从低位到高位的交替数字和」与「从高位到低位到交替数字和」的差别。
//  当 n = 521
//  - 从高位到低位到交替数字和：(+5) + (-2) + (+1) = 5
//  - 从低位到高位的交替数字和：(+1) + (-2) + (+5) = 5

// 当 n = 5321
//  - 从高位到低位到交替数字和：(+5) + (-3) + (+2) + (-1) = 3
//  - 从低位到高位的交替数字和：(+1) + (-2) + (+3) + (-5) = -3

// 不难发现，n 有奇数位时，从高位到低位 和 从低位到高位 交替数字和是一致的。而 n 有偶数位时，两者结果为「相反数」，且结束时最后的符号为 - 。
// 因此，我们可以求数字 n 的低位到高位的交替和，最后再乘以最后的符号变量即可。

// 具体的，使用一个 sign 来表示数字的正负号，初始值为 1。每一步中，我们将 n 对 10 取模，获得它的最低位，再把它和 sign 相乘求和，再将 sign 取反，把 n 除以 10。
// 不断重复，直到 n 为 0。由于最后高位计算结束后，符号还会变化一次，因此最后只需要乘以最后相反的符号即可。

/**
 * @param {number} n
 * @return {number}
 */
var alternateDigitSum = function (n) {
  let sum = 0;
  let sign = 1; // 初始化符号位为1，表示正号
  while (n > 0) {
    sum += sign * (n % 10); // n % 10 获取当前最低位，乘以 sign 得到交替符号
    sign *= -1; // sign 符号交替变化
    n = (n / 10) | 0; // 除10向下取整，去除 n 的最低位
  }
  // n 为奇数位时，结束时候 sign 为 负数，乘以 -sign，即为 sum * 1 与高位一致。
  // n 为偶数位时，结束时候 sign 为 正数，乘以 -sign，即为 sum * -1 与高位结果相同。
  return sum * -sign;
};
// 时间复杂度：O(logn)，n 为 数字的位数。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
