// 给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都恰有一条出边。
// 图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的有向边。
// 节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。
// 返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。

//          [2]                        [6]
//           |                          |
//           v                          v
// [1] <--> [0]  <-- [3]      [5] <--> [7]
//           |
//           v
//          [4]
// 输入：edges = [1,0,0,0,0,7,7,5]
// 输出：7
// 解释：
// - 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。
// - 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。
// - 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。
// - 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。
// 节点 7 的边积分最高，所以返回 7 。

// [1]      [3]
//  |        |
//  v        v
// [0] <--> [2]
// 输入：edges = [2,0,0,2]
// 输出：0
// 解释：
// - 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。
// - 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。
// 节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。

// 方法一：一次遍历
// 由题意可知，edges 数组代表一个有向图，edges[i] 表示从节点 i 指向节点 edges[i] 的有向边。对于任意节点 i ，其边积分为所有指向 i 的边的节点编号之和，即所有 edges[j] === i 的 j 之和。
// 我们可以使用一个长度为 n 的数组 score 记录每个节点的边积分，初始时每个元素都为 0 。
// 遍历数组 edges ，对于每个 edges[i] ，将 score[edges[i]] 加上 i 。
// 返回 score 数组中最大的元素对应的下标。即为边积分最高的节点。

// 额外的，为了不需要额外再次遍历 score 数组以获得其最大的元素对应的下标，我们在构建 score 数组的同时，使用变量 ans 记录最大值对应的下标。

// 具体的，
// 遍历数组 edges，对于每个节点 i，以及它的出边节点 edges[i]，我们更新 score[edges[i]] += i 。
// 同时维护当前 score 数组中最大值对应的下标 ans ，如果 score[edges[i]] > score[ans] 或者 score[edges[i]] === score[ans] 且 edges[i] < ans 则更新 ans为 edges[i] 。
/**
 * @param {number[]} edges
 * @return {number}
 */
var edgeScore = function (edges) {
    const n = edges.length;

    // 初始化 score 数组，存储每个节点的边积分，初始为 0
    const score = new Array(n).fill(0);
    let ans = 0; // 用于跟踪边积分最高的节点编号，初始值设为 0

    for (let i = 0; i < n; i++) {
        const to = edges[i]; // 当前节点 i 指向的目标节点是 edges[i]
        score[to] += i; // 更新目标节点 to 的边积分

        // 如果目标节点 to 的边积分比当前最大边积分大，或者相等但 to 的编号小于 ans，均需更新 ans。
        if (score[to] > score[ans] || (score[to] === score[ans] && to < ans)) {
            ans = to;
        }
    }
    // 返回边积分最高的节点编号
    return ans;
};
// 时间复杂度：O(n)，n 为数组 edges 的长度，我们需要对其进行遍历一次。
// 空间复杂度：O(n)，n 为数组 edges 的长度，需要一个长度为 n 的 score 数组来存储每个节点的边积分。
