// 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。

// 输入：n = 2
// 输出：["1/2"]
// 解释："1/2" 是唯一一个分母小于等于 2 的最简分数

// 输入：n = 3
// 输出：["1/2","1/3","2/3"]

// 输入：n = 4
// 输出：["1/2","1/3","1/4","2/3","3/4"]
// 解释："2/4" 不是最简分数，因为它可以化简为 "1/2" 。

// 输入：n = 1
// 输出：[]


/**
 * @param {number} n
 * @return {string[]}
 */
// 方法一：哈希表
// 思路：这道题目唯一的难点在于，结果数组里面存放的是最简分数，举例来说，当n是4的时候，"2/4" 不是最简分数，因为它可以化简为 "1/2"，所以"2/4"不能加入结果集中
// 那怎么样判断重复呢，如果map里面的key存的是"2/4"的值0.5呢，那如果已经存了"1/2"的值0.5，通过map就可以判断"2/4"的值0.5已经存在map中了，就不加入结果集中。
var simplifiedFractions = function (n) {
    const map = new Map();
    const res = [];
    for (let i = 1; i < n; i++) { // i 表示分子
        for (let j = i + 1; j <= n; j++) { // j 表示分母
            const key = i + '/' + j;
            // "2/4" 和 "1/2" 真正的值是一样的，通过map就可以判断出来  只有值不相同的情况下才加入结果集中
            if (!map.get(eval(key))) res.push(key);
            map.set(eval(key), true);
        }
    }
    return res;
};
// 时间复杂度：O(n^2)，分子分母的组合需要暴力枚举。
// 空间复杂度：O(n)。建立map需要O(n)的空间。


// 方法二：数学 - 欧几里得算法(辗转相除法)
// 欧几里得算法求 12 和 16 的最大公约数:
// 16 / 12 = 1...4
// 12 / 4  = 3...0
// 至此，最大公约数为4 

// 思考什么是最简分数？为什么"2/4"不是最简分数，"1/2"确实呢？
// 因为"2/4"当中2和4最大公约数是2，而最简分数中的分子分母的最大公约数是1
// 由此我们可以通过判断分子分母的最大公约数是否为1判断是否为最简分数

// 思路：遍历组合分子和分母，如果最大公约数为1则加入结果数组中

var simplifiedFractions = function (n) {
    const res = []; // 结果集
    for (let i = 1; i < n; i++) { // i 表示分子
        for (let j = i + 1; j <= n; j++) { // j 表示分母
            // 如果最大公约数为1 则是最简分数，加入结果集中
            if (gcd(i, j) === 1) res.push(i + '/' + j);
        }
    }
    return res;
};

// 辅助函数（欧几里得算法）
const gcd = (a, b) => {
    if (b === 0) {
        return a;
    }
    return gcd(b, a % b);
}
// 时间复杂度：O(n^2 log n)。需要暴力枚举分子分母的组合时间复杂度为O(n^2)，每对分子分母计算最大公约数和生成字符串的复杂度均为O(logn)。
// 空间复杂度：O(1)。除结果数组外，我们只需要常数的空间存放若干变量。