// n 个朋友在玩游戏。这些朋友坐成一个圈，按 顺时针方向 从 1 到 n 编号。从第 i 个朋友的位置开始顺时针移动 1 步会到达第 (i + 1) 个朋友的位置（1 <= i < n），而从第 n 个朋友的位置开始顺时针移动 1 步会回到第 1 个朋友的位置。

// 游戏规则如下：
// 第 1 个朋友接球。
//  - 接着，第 1 个朋友将球传给距离他顺时针方向 k 步的朋友。
//  - 然后，接球的朋友应该把球传给距离他顺时针方向 2 * k 步的朋友。
//  - 接着，接球的朋友应该把球传给距离他顺时针方向 3 * k 步的朋友，以此类推。
// 换句话说，在第 i 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 i * k 步的朋友。

// 当某个朋友第 2 次接到球时，游戏结束。
// 在整场游戏中没有接到过球的朋友是 输家 。
// 给你参与游戏的朋友数量 n 和一个整数 k ，请按升序排列返回包含所有输家编号的数组 answer 作为答案。

/**
 * @param {number} n
 * @param {number} k
 * @return {number[]}
 */
// 方法一：模拟
// 使用一个数组 vis 记录每个朋友是否接到过球，初始时所有朋友都没有接到过球。
// 然后我们按照题目描述的规则模拟游戏的过程，直到某个朋友第二次接到过球为止。
// 模拟过程中，我们使用变量 i 和 round 分别表示当前接球朋友的编号和当前传球的轮次，初始值为 i = 0，p = 1。
// 每次传球时，将 i 更新为 (i + round * k) % n，表示下一个接球的朋友编号，然后将 round + 1 以更新轮次。
// 当有朋友之前接到过球，现在是第二次触球，则游戏结束。使用变量 hasLosers 表示游戏是否结束，结束了则说明产生了输家。
// 最后遍历一次 vis 数组，将没有接到过球的朋友编号加入到答案中即可。
var circularGameLosers = function (n, k) {
  const vis = new Array(n).fill(false); // 记录每个朋友是否接到过球
  let i = 0; // 当前接球朋友的编号，从下标0开始
  let round = 1; // 当前传球的轮次，下一个接球朋友的下标是 (i + round * k) % n
  let hasLosers = false; // 记录当前是否有人第二次触球

  // game start!
  while (!hasLosers) {
    // 如果这个人之前触过球，则游戏结束，输家已经产生
    if (vis[i]) {
      hasLosers = true;
    }
    vis[i] = true; // 将当前接球朋友标记为触球过
    i = (i + round * k) % n; // 计算下一个接球朋友的下标
    round++; // 传球轮次+1
  }

  // 输出没接到过球的输家
  const res = [];
  for (let i = 0; i < n; i++) {
    if (!vis[i]) res.push(i + 1); // 由于题目给定的编号从1开始，而我们是0开始，存在1的偏移量，因此需要 +1
  }
  return res;
};
// 时间复杂度：O(n)，n 为给定的数字，一共有 n 个位置，由于每个位置最多被访问一次，因此时间复杂度为O(n)。
// 空间复杂度：O(n)，我们需要一个长度为 n 的数组用于记录每个朋友是否接到过球。
