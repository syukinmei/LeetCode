// 给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。

// 你可以按下面两个规则参与项目中的工作：
//  - 每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
//  - 在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。

// 一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。
// 返回在不违反上面规则的情况下你 最多 能工作多少周。

// 输入：milestones = [1,2,3]
// 输出：6
// 解释：一种可能的情形是：
// ​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
// - 第 2 周，你参与并完成项目 2 中的一个阶段任务。
// - 第 3 周，你参与并完成项目 1 中的一个阶段任务。
// - 第 4 周，你参与并完成项目 2 中的一个阶段任务。
// - 第 5 周，你参与并完成项目 1 中的一个阶段任务。
// - 第 6 周，你参与并完成项目 2 中的一个阶段任务。
// 总周数是 6 。

// 输入：milestones = [5,2,1]
// 输出：7
// 解释：一种可能的情形是：
// - 第 1 周，你参与并完成项目 0 中的一个阶段任务。
// - 第 2 周，你参与并完成项目 1 中的一个阶段任务。
// - 第 3 周，你参与并完成项目 0 中的一个阶段任务。
// - 第 4 周，你参与并完成项目 1 中的一个阶段任务。
// - 第 5 周，你参与并完成项目 0 中的一个阶段任务。
// - 第 6 周，你参与并完成项目 2 中的一个阶段任务。
// - 第 7 周，你参与并完成项目 0 中的一个阶段任务。
// 总周数是 7 。
// 注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
// 因此，项目 0 中会有一个阶段任务维持未完成状态。

// 方法一：贪心 + 抽屉原理
// 本题大意是：有 sum(milestones) 个任务，要求每周完成一个任务，且相邻周不能完成相同任务。求最多可以持续多少周。
// 为了保证相邻周不完成相同的任务，我们相当于要在相同的任务中进行插空，使得这些任务彼此不相同。
// 为了使持续周最多，我们可以贪心的优先完成任务数量最多的项目 x，并且相邻周之间使用 1 个其他任务进行插空。

// 记所有项目的任务数为 total = sum(milestones)。
// 任务数量最多的项目 x 的任务数量为 most = max(milestones)。
// 其余项目的任务数量为 rest = total - most。

// 将 x 用抽屉隔开，形如 x_x_x_x_x，将其他剩余任务依次填入其中，这样操作保证了不会有任务在相邻周。
// 注意，为了使持续周最多，那么两个 x 之间应该只有一个抽屉（即一个其他任务）。

// 不难发现:
//  1. 如果有至少 most - 1 个其他任务，即 rest >= most - 1，则可以完成整个项目，持续 total 周。
//  2. 否则我们无法完成任务数量最多的项目 x。项目 x 中的任务最多完成 rest + 1 个，那么则可以持续 2 * rest + 1 周。
/**
 * @param {number[]} milestones
 * @return {number}
 */
var numberOfWeeks = function (milestones) {
    const most = Math.max(...milestones); // 任务数量最多的项目任务数
    const rest = milestones.reduce((acc, cur) => acc + cur, 0) - most; // 其余项目的任务数量

    // 此时可以完成所有工作
    if (rest >= most - 1) return rest + most;
    // 此时无法完成任务数量最多的项目
    else return rest * 2 + 1;
};
// 时间复杂度：O(n)，n 为数组 milestones 的长度，需要进行一次遍历以计算任务数量最多的项目任务数和所有项目的任务数。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
