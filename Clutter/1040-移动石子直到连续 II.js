// 在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。
// 每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。
// 值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。
// 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
// 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。

// 输入：[7,4,9]
// 输出：[1,2]
// 解释：
// 我们可以移动一次，4 -> 8，游戏结束。
// 或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。

// 输入：[6,5,4,3,10]
// 输出：[2,3]
// 解释：
// 我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
// 或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
// 注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。

// 输入：[100,101,104,102,103]
// 输出：[0,0]


// 方法一：排序+分类讨论+双指针
// 对数组 stones 中的石子按照位置大小升序排序。分别考虑最大移动次数 mx 和最小移动次数 mi。
// 对于最大移动次数 mx：
//  - 我们只需要 stones[0] 或者 stones[n-1] 端移动，每次移动都将端点石子移动到最近的空位即可。
//  - 对于第一次移动，无论选择哪一段，我们都会废弃 stones[0] 和 stones[1] 或者 stones[n-1] 和 stones[n-2] 之间的空位。
//  - 对于后面的空位都不会被废弃而是一一占据。如 [1, 4, 6, 9, 13]
//      无论移动1那一端还是10那一段，比如 1 的左端点，我们会废弃 2 3 将 1 移动到 5，然后 左侧端点以此占据剩余空位。
//  - 所以最大操作次数为 Math.max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)

// 对于最小移动次数 mi：
// 我们找一个最长的连续的石子序列，然后进行分类讨论，假设其中连续排列的石子数量为k
//  - 如果 k = n-1：
//      则有如下例子 [1, 2, 3, 9] ，3 和 9 中间有 5 个空位，我们需要移动2次，1->5，9->4。
//      或者 [1, 2, 3, 5]，3 和 5 中间有1个空位，则只需要移动一次，1->4。
//  - 如果 k != n-1
//      那么最少移动次数为 n - k 即可。
// 具体的：
// 我们用双指针 i 和 j 表示一个窗口的左右端点，若窗口内的位置数 stones[j] - stones[i] + 1 > n 时，我们需要缩小窗口，即指针 i 右移。
// 如果窗口中有连续的 n-1 个石子，即满足 j-i+1 = n-1 且 stones[j] - stones[i] = n - 2 (前者判断数量，后者判断是否连续)，那么最少移动次数为 2。否则，我们用 n 减去窗口内的石子数，即可得到最少需要的移动次数，即 n - (j-i+1)。取所有情况的最小值作为答案即可。
/**
 * @param {number[]} stones
 * @return {number[]}
 */
var numMovesStonesII = function (stones) {
  // step1：将石头按升序排序
  stones.sort((a, b) => a - b);
  const n = stones.length;

  // step2：求最大移动次数
  const moveLeft = stones[n - 1] - stones[1] - n + 2;
  const moveRigth = stones[n - 2] - stones[0] - n + 2;
  const mx = Math.max(moveLeft, moveRigth);

  // step3：求最小移动次数
  let mi = n;
  let i = 0,
    j = 0;
  for (j; j < n; j++) {
    // 缩小窗口，用于维护窗口长度，我们的窗口需要<=n
    while (stones[j] - stones[i] + 1 > n) i++; // 找到最小的 i，使得 stones[j] - stones[i] + 1 <= n
    if (j - i + 1 === n - 1 && stones[j] - stones[i] === n - 2)
      mi = Math.min(2, mi);
    // 特俗情况：只需要移动两个石头
    else mi = Math.min(mi, n - (j - i + 1)); // 移动 n-(j-i+1) 个石头
  }
  // 返回结果
  return [mi, mx];
};
// 时间复杂度O(nlogn)，n 为数组 stones 的长度即石子个数量。主要为排序的时间复杂度。
// 空间复杂度O(logn)，n 为数组 stones 的长度即石子个数量。主要为排序的空间开销。
