// 给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。

// 返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。

// 输入：tasks = [2,2,3,3,2,4,4,4,4,4]
// 输出：4
// 解释：要想完成所有任务，一个可能的计划是：
// - 第一轮，完成难度级别为 2 的 3 个任务。
// - 第二轮，完成难度级别为 3 的 2 个任务。
// - 第三轮，完成难度级别为 4 的 3 个任务。
// - 第四轮，完成难度级别为 4 的 2 个任务。
// 可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。

// 输入：tasks = [2,3,3]
// 输出：-1
// 解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。

// 方法一：哈希表 + 贪心
// 本题可以分为两步来完成：
// 1. 统计每个难度级别任务的数量：使用一个「哈希表」来记录每个难度级别任务的数量。
// 2. 计算最少轮数：遍历哈希表，计算每个难度级别的任务需要的最少轮数。如果某个难度级别的任务数量不能通过每轮完成2个或3个的方式来完成，则返回 -1。

// 对于第 2 点，每轮完成的都是相同难度级别的任务，假设任务难度为 1 的任务有 x 个，问题就变成了：
//  - 每轮可以将 x 减少 2 个或者 3 个，把 x 减少到 0 最少需要多少轮？
// 为了让轮次尽可能少，我们应该贪心地尽多地完成任务，即使用「减少3」。
// 分类讨论：
//  - 如果 x = 1，无法完成，返回 -1。
//  - 如果 x = 3k (k >= 1)，那么每轮可以减少 3 个，总共需要 x/3 轮。
//  - 如果 x = 3k + 1 (k >= 1)，通过转换可以得到 x = 3 * (k - 1) + 4，即先使用「减少3」 把 x 减少到 4，然后再使用 2 次「减少2」完成任务。需要的轮次为 (x - 4) / 3 + 2 = (x + 2) / 3 =  ⌈ x/3 ⌉
//  - 如果 x = 3k + 2 (k >= 1)，我们可以先使用「减少3」把 x 减少到 2，然后再使用 1 次「减少2」完成任务。需要的轮次为 (x - 2) / 3 + 1 = (x + 1) / 3 = ⌈ x/3 ⌉

// Q：为什么任务数量 count 大于等于 2 的情况，我们确定可以通过每轮完成 3 个或者 2 个任务的组合来完成所有任务？
// A：因为「任何大于等于 2 的整数都可以表示为 3 和 2 的线性组合」，即 对于任意的 count >= 2，我们都可以找到非负整数 x 和 y 使得 3x + 2y = count。
//   也可以理解为：当增加 1 个任务时，可以通过再加一轮 2 个任务或减少一轮 3 个任务并加两轮 2 个任务来平衡。

/**
 * @param {number[]} tasks
 * @return {number}
 */
var minimumRounds = function (tasks) {
  // step1：使用哈希表统计每个难度级别的任务数量
  const taskCnt = new Map();
  for (const task of tasks) {
    taskCnt.set(task, (taskCnt.get(task) || 0) + 1);
  }

  // step2：遍历哈希表中每个任务，计算完成所有任务需要的最少轮次

  let rounds = 0; // 完成所有任务需要的最少轮数
  for (const [task, count] of taskCnt) {
    // 如果某个难度级别只有 1 个任务，则无法完成
    if (count === 1) {
      return -1;
    }

    // 可以通过 2 和 3 来完成任务，则累计需要的最少轮次

    // 尽可能多地使用3个任务一轮的方式
    rounds += Math.floor(count / 3);

    // 如果有剩余任务，则再增加一轮
    if (count % 3 !== 0) {
      rounds += 1;
    }

    // rounds += Math.ceil(count / 3); // 或者直接向上取整
  }

  return rounds;
};
// 时间复杂度：O(n)，n 为数组 tasks 的长度。需要遍历对其进行遍历以统计任务数量和计算每种任务完成所需的轮次。
// 空间复杂度：O(n)，n 为数组 tasks 的长度。需要使用哈希表来存储每个难度级别的任务数量，最坏情况下每种任务都不同。
