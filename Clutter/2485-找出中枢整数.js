// 给你一个正整数 n ，找出满足下述条件的 中枢整数 x ：

//  -  1 和 x 之间的所有元素之和等于 x 和 n 之间所有元素之和。
// 返回中枢整数 x 。如果不存在中枢整数，则返回 -1 。题目保证对于给定的输入，至多存在一个中枢整数。

// 输入：n = 8
// 输出：6
// 解释：6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。

// 输入：n = 1
// 输出：1
// 解释：1 是中枢整数，因为 1 = 1 。

// 输入：n = 4
// 输出：-1
// 解释：可以证明不存在满足题目要求的整数。

// tips:
// 1 <= n <= 1000

// 方法一：前缀和数组
// 利用前缀和的特性，快速计算区间内元素之和。
// 具体的：
// 遍历 1 到 n 的队列，生成其前缀和数组 preSum。
// 对于数字 i，判断其是否是中枢整数，只需要比较前缀和数组的第 i 项 和 第 n 项减去第 i - 1 即可。
// 即：preSum[i] === preSum[n] - preSum[i-1]。
// 因为前缀和数组的特性，preSum[i] 表示 1 到 i 的和；preSum[n] - preSum[i-1] 表示 i 到 n 的和。
/**
 * @param {number} n
 * @return {number}
 */
var pivotInteger = function (n) {
  const preSum = new Array(n + 1).fill(0);
  // 计算前缀和数组。
  for (let i = 1; i <= n; i++) {
    preSum[i] = preSum[i - 1] + i;
  }
  for (let i = 1; i <= n; i++) {
    const prefix = preSum[i];
    const suffix = preSum[n] - preSum[i - 1];
    if (prefix === suffix) return i;
  }
  return -1; // 1到n中不存在中枢整数，返回-1
};
// 时间复杂度：O(n)，需要遍历一次1到n的数列，计算前缀和数组需要O(n)的时间复杂度，对于每个数判断是否为中枢整数需要O(n)的时间复杂度，因此总的时间复杂度为O(n)。
// 空间复杂度：O(n)，用于存储前缀和数组。

// 方法二：前缀和优化前缀和数组的空间复杂度
// 由于前缀和数组适用于频繁计算区间元素和，但是对于每个区间我们只需要计算一次，即前缀和数组的每一项我们只使用了一次，我们需要计算的只是将数组分为两半，计算两边的和即可。
// 我们可以在遍历队列时，维护前缀和 prefix 表示队列前部元素和，后部元素和即 suffix = sum - prefix。
// 具体的，计算 1 到 n 的数列的和为 sum。遍历数列每个值，维护 prefix 表示 0 到当前值 i 的和。suffix 表示 当前值 i 到 n 的和。
// 对于当前遍历的值 i ，如果 prefix === suffix ，则 i 是 中枢整数。
// 遍历结束后未找到中枢整数，则返回 -1。
/**
 * @param {number} n
 * @return {number}
 */
var pivotInteger = function (n) {
  const sum = (n * (n + 1)) / 2; // 使用等差数列求和公司计算数列总和，即 1到n 的和
  let prefix = 0; // 前缀元素和，即 1到i 的和
  for (let i = 1; i <= n; i++) {
    prefix += i; // 更新前缀元素和
    let suffix = sum - prefix + i; // 后缀元素和，即 i到n 的和
    if (prefix === suffix) return i; // 判断前缀和后缀的和是否相等，相等则 i 是 中枢整数
  }
  return -1; // 1到n中不存在中枢整数，返回-1
};

// 方法三：等差数列求和公式优化
// 由于题目给定的 n 是从1到n的队列是一个公差为 1 的等差数列。
// 遍历等差数列的每一项 x，根据等差数列求和公式：
// an = a1 + (n-1)d  Sn = n * a1 + n(n-1)d/2  或 Sn = n(a1 + an) / 2
//  - 1 和 x 之间的所有元素之和为 (x * (1 + x)) / 2;
//  - x 和 n 之间的所有元素之和为 ((n - x + 1) * (x + n)) / 2;
// 因此，判断 x 是否为中枢整数的条件，只需要判断以下等式是否成立：
//  - x * (1 + x) === (n - x + 1) * (x + n);
/**
 * @param {number} n
 * @return {number}
 */
var pivotInteger = function (n) {
  for (let x = 1; x <= n; x++) {
    if (x * (1 + x) === (n - x + 1) * (x + n)) return x;
  }
  return -1;
};
// 时间复杂度：O(n)，n 为给定正整数 n。需要枚举 1 到 n 的每个正整数。
// 空间复杂度：O(1)，只需要常数的空间存放若干遍历。

// 方法四：数学
// 根据方法三判断 x 是否为中枢整数的公式：
//  - x * (1 + x) === (n - x + 1) * (x + n)
// 变形得到：
// (2 * x) ^ 2 === n * (n + 1)
// 即： x = Math.sqrt((n * (n + 1)) / 2)
// 我们直接利用变形后的公式查找 x，如果 x 为整数，则 x 为中枢整数，否则不存在中枢整数。
var pivotInteger = function (n) {
  const x = Math.sqrt((n * (n + 1)) / 2);
  return x % 1 === 0 ? x : -1; // 如果 x 为整数，则 x 为中枢整数，否则不存在中枢整数返回-1。
};
// 时间复杂度：O(1)。
// 空间复杂度：O(1)，只需要常数的空间存放若干遍历。
