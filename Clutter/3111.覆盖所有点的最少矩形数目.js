// 给你一个二维整数数组 point ，其中 points[i] = [xi, yi] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。
// 每个矩形的左下角在某个点 (x1, 0) 处，且右上角在某个点 (x2, y2) 处，其中 x1 <= x2 且 y2 >= 0 ，同时对于每个矩形都 必须 满足 x2 - x1 <= w 。
// 如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。
// 请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。
// 注意：一个点可以被多个矩形覆盖。

// 输入：points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
// 输出：2
// 解释：
//  - 一个矩形的左下角在 (1, 0) ，右上角在 (2, 8) 。
//  - 一个矩形的左下角在 (3, 0) ，右上角在 (4, 8) 。

// 输入：points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
// 输出：3
// 解释：
//  - 一个矩形的左下角在 (0, 0) ，右上角在 (2, 2) 。
//  - 一个矩形的左下角在 (3, 0) ，右上角在 (5, 5) 。
//  - 一个矩形的左下角在 (6, 0) ，右上角在 (6, 6) 。

// 输入：points = [[2,3],[1,2]], w = 0
// 输出：2
// 解释：
//  - 一个矩形的左下角在 (1, 0) ，右上角在 (1, 2) 。
//  - 一个矩形的左下角在 (2, 0) ，右上角在 (2, 3) 。

// 方法一：贪心
// 根据题目描述，我们不需要考虑矩形的高度，只需要关心矩形的宽度。
// 贪心思路：为了让矩形覆盖更可能多的点，矩形的宽度越大越好，因此我们可以假定矩形的宽度为 w。
// 假定当前所有点的最小横坐标为 x0，必须有一个宽度为 w 的矩形来覆盖该很坐标，为了让矩形覆盖更多的点，此时矩形左边缘的横坐标为 x0，右边缘的横坐标为 x0 + w，此时该矩形可以覆盖所有横坐标在区间 [x0, x0 + w] 内的点。
// 接着我们考虑剩余点中横坐标最小的点，继续按照上述贪心思路，直到覆盖所有的点。
// 具体的：
//  1. 首先对 points 按照横坐标 points[i][0] 进行升序排序。
//  2. 第一个矩形的放置位置 start = points[0][0]（一开始将矩形放在最左侧的点上，矩形覆盖范围即为 [start, start + w] ）。
//  3. 我们从第二个点开始依次判断：
//     - 如果当前点的横坐标 points[i][0] <= start + w ，即在矩形覆盖范围内 [start, start + w]，则不需要新增矩形，继续判断下一个点。
//     - 否则，当前点不能被覆盖，需要在当前点放置一个新的矩形（res+1），新矩形的起点为 start = points[i][0]，其覆盖范围为 [start, start + w]，继续判断下一个点。
//  4. 遍历结束后，我们就得到了最少需要的矩形数，最终返回 res 即可。

// 在代码实现方面，我们真正要关心的是当前矩形所能覆盖的最右边的横坐标，因此，我们用 x1 表示当前矩形所能覆盖的最右边的横坐标。初始时 x1 = -1。
// 接下来我们遍历所有点，如果当前点的横坐标 x 大于 x1，说明已有的矩形无法覆盖当前点，需要新增一个矩形，res + 1，同时更新 x1 = x + w。

// Q: 为什么「我们不需要考虑矩形的高度」，题目明明限制了 “右上角在某个点（x2,y2）处” ？
// A: 
//    1、这里说的某个点（x2,y2）并不是说是 points 给出来的点，而是代指矩形是由两个点确定的，一个在左下角(x1, 0)，一个在右上角(x2,y2)，用这两个点即可勾勒出一个唯一的矩形。
//    2、不关心的是矩形的高度的具体原因是，由于题目对 y2 的限制只要求 y 2大于等于0，并且我们的贪心策略是矩形宽度拉满为 w，然后高度无限高，这样可以覆盖尽可能多的点，因此我们不需要关心矩形的高度。

/**
 * @param {number[][]} points
 * @param {number} w
 * @return {number}
 */
var minRectanglesToCoverPoints = function (points, w) {
    points.sort((a, b) => a[0] - b[0]); // 按照横坐标 points[i][0] 进行升序排序
    let res = 0; // 记录需要矩形的数目
    let x1 = -1; // 记录当前矩形所能覆盖的最右边的横坐标

    // 遍历所有点的横坐标 x，判断至少需要多少个矩形可以覆盖
    for (const [x, _] of points) {
        // 无法覆盖
        if (x > x1) {
            res++;
            x1 = x + w;
        }
    }
    return res;
};
// 时间复杂度：O(nlogn)，n 为二维数组 points 的长度。排序需要 O(nlogn)的时间，遍历所有点需要 O(n) 的时间，因此总时间复杂度为 O(nlogn)。
// 空间复杂度：O(logn)，快排需要 O(logn)的递归栈空间。
