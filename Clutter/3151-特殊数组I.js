// 如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。
// Aging 有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。

// 输入：nums = [1]
// 输出：true
// 解释：
// 只有一个元素，所以答案为 true。

// 输入：nums = [2,1,4]
// 输出：true
// 解释：
// 只有两对相邻元素： (2,1) 和 (1,4)，它们都包含了奇偶性不同的数字，因此答案为 true。

// 输入：nums = [4,3,1,6]
// 输出：false
// 解释：
// nums[1] 和 nums[2] 都是奇数。因此答案为 false。

// 方法一：模拟
// 按照题目要求对数组 nums 进行一次遍历，每次遍历时判断当前数组 nums[i] 和前一个数字 nums[i-1] 的奇偶性是否不同。

// 获取一个数的奇偶性有两种方式：
//  - 模 2：nums[i] % 2，0 为偶数，1 为奇数。
//  - 按位与 1 ：nums[i] & 1，0 为偶数，1 为奇数。（通常，一个数如果是奇数，其二进制形式的最低位（最右边的位）是 1；如果是偶数，则最低位是 0。因此，我们可以通过对每个数与 1 进行按位与（&）运算来判断其奇偶性，如果结果为 1 则是奇数，为 0 则是偶数。）
// 判断两个数的奇偶性是否不同：
//  - 直接等号判断其奇偶性是否相同。
//  - 按位异或：奇偶性同 0 或同 1为 0，不同为 1。

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isArraySpecial = function (nums) {
    // 遍历一次数组，查看是否有相邻元素奇偶性相同的
    for (let i = 1; i < nums.length; i++) {
        // if (nums[i] % 2 === nums[i - 1] % 2) return false;
        if (!(nums[i] & 1) ^ (nums[i - 1] & 1)) return false;
    }
    // 相邻元素奇偶性均不同，返回 true
    return true;
};
// 时间复杂度：O(n)，n 为数组 nums 的长度，需要对数组进行一次遍历，以判断相邻元素的奇偶性是否不同。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
