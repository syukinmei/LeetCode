// 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

// 输入：n = 5
// 输出：true
// 解释：5 的二进制表示是：101

// 输入：n = 7
// 输出：false
// 解释：7 的二进制表示是：111.

// 输入：n = 11
// 输出：false
// 解释：11 的二进制表示是：1011.


/**
 * @param {number} n
 * @return {boolean}
 */
// 方法一：模拟
// 从最低位至最高位，我们对 n 2 取模再除以 2 的方法，依次求出输入的二进制表示的每一位，并与前一位进行比较。如果相同，则不符合条件；如果每次比较都不相同，则符合条件。
var hasAlternatingBits = function (n) {
    let prev = null;
    while (n > 0) {
        const cur = n % 2
        if (cur === prev) return false;
        prev = cur
        // n = Math.floor(n / 2);
        n = n >> 1;
    }
    return true;
};
// 时间复杂度：O(logn)，输入 n 的二进制表示最多有O(logn)位。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。


// 方法二：位运算
// Tips：当 n 为交替位二进制数时，n 与 n右移一位 刚好错开，它们异或的结果所有位都是 1 。
// 如何快速判断全部位都是1呢？其实就是判断是否异或结果为 2的幂次减1 。
// 判断一个数是否是 2的幂次 方法为 num & (num - 1) == 0 
//  - 原因：因为2的N次方换算是二进制为10……0这样的形式(0除外)。与上自己-1的位数，这们得到结果为0
// 推理得：判断一个数是否是 2的幂次减1 方法为 (num + 1) & num == 0
var hasAlternatingBits = function (n) {
    const a = n ^ (n >> 1);
    // 判断 a 的二进制位是否全是1。
    return (a & (a + 1)) === 0;
};
// 时间复杂度：O(1)，仅使用常数时间来计算。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
