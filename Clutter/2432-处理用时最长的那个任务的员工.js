// 共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id 。
// 给你一个二维整数数组 logs ，其中 logs[i] = [idi, leaveTimei] ：
//  - idi 是处理第 i 个任务的员工的 id ，且
//  - leaveTimei 是员工完成第 i 个任务的时刻。所有 leaveTimei 的值都是 唯一 的。
// 注意，第 i 个任务在第 (i - 1) 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。
// 返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 最小 的 id 。

// 输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]
// 输出：1
// 解释：
// 任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。
// 任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。
// 任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。
// 任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。
// 时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。

// 输入：n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]
// 输出：3
// 解释：
// 任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。
// 任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。
// 任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。
// 任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。
// 时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。

// 输入：n = 2, logs = [[0,10],[1,20]]
// 输出：0
// 解释：
// 任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。
// 任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。
// 时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。

/**
 * @param {number} n
 * @param {number[][]} logs
 * @return {number}
 */
// 枚举每个员工
// 对数组 logs 进行一次遍历，算出其中每位员工处理任务的耗时来推出答案
// 具体的，我们在遍历时 维护两个变量 maxCost 和 longestId 前者表示最长的处理耗时，后者表示其对应的员工
// 首个任务从时刻 0 开始，因此初始时，我们将这两个变量赋值为 logs[0] 中的两个值。随后我们从 logs[1] 开始遍历，通过相邻两项的差值计算出处理耗时，并根据题意维维护 maxCost 和 longestId 即可
var hardestWorker = function (n, logs) {
  let [longestId, maxCostTime] = logs[0]; // 初始化处理任务用时最长的员工 id 及其 处理时间
  for (let i = 1; i < logs.length; i++) {
    const curId = logs[i][0];
    const costTime = logs[i][1] - logs[i - 1][1]; // id 为 curId 的员工任务处理时间，即当前任务结束刻度 - 上一个任务结束刻度
    // 1.有更长耗时的员工时，更新 longestId 和 maxCostTime 为 耗时更长的员工的值
    // 2.有相同耗时的员工时，更新 longestId 和 maxCostTime 为 id 较小的值
    if (
      costTime > maxCostTime ||
      (costTime === maxCostTime && longestId > curId)
    ) {
      longestId = curId;
      maxCostTime = costTime;
    }
  }
  return longestId;
};
// 时间复杂度：O(n)，n为数组 logs 的长度，需要遍历一次数组。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
