// 你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。
// 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
// 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。


// 输入：a = 2, b = 4, c = 6
// 输出：6
// 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：
// - 从第一和第三堆取，石子状态现在是 (1, 4, 5)
// - 从第一和第三堆取，石子状态现在是 (0, 4, 4)
// - 从第二和第三堆取，石子状态现在是 (0, 3, 3)
// - 从第二和第三堆取，石子状态现在是 (0, 2, 2)
// - 从第二和第三堆取，石子状态现在是 (0, 1, 1)
// - 从第二和第三堆取，石子状态现在是 (0, 0, 0)
// 总分：6 分 。


// 输入：a = 4, b = 4, c = 6
// 输出：7
// 解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是：
// - 从第一和第二堆取，石子状态现在是 (3, 3, 6)
// - 从第一和第三堆取，石子状态现在是 (2, 3, 5)
// - 从第一和第三堆取，石子状态现在是 (1, 3, 4)
// - 从第一和第三堆取，石子状态现在是 (0, 3, 3)
// - 从第二和第三堆取，石子状态现在是 (0, 2, 2)
// - 从第二和第三堆取，石子状态现在是 (0, 1, 1)
// - 从第二和第三堆取，石子状态现在是 (0, 0, 0)
// 总分：7 分 。


// 贪心
// 不妨设 a<=b<=c ，那么题目可以分解为两种情况：
//  - 1、a+b<=c，在这种情况下可以将 a 和 b 中的每个石子与 c 配对。答案为 a+b。
//  - 2、a+b>c，在这种情况下将 c 中的所有石子与 a 或 b 中的石子配对，配对过程中总是优先匹配 a 和 b 中较大的那一个，最终 a 和 b 大小相等或者相差 1。然后 a 和 b 中剩下的两两配对即可。
//    为了表示结果，设 a 与 c 配对次数为 ka，b 与 c 配对次数为 kb，并且 ka + kb = c，因此答案为 (ka+kb) + [(a-ka)+(b-kb)/2]，简化后可得到 (a+b+c)/2 。
// 上面假设了 a<=b<=c，代码中实际上只关心 a+b 的值以及 c 的值，所以可以用 max(a,b,c) 求出排序后的 c，a+b+c-max(a,b,c) 求出排序后的 a+b 。
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
var maximumScore = function (a, b, c) {
    const sum = a + b + c;
    const maxVal = Math.max(a, b, c);
    return sum - maxVal > maxVal ? sum >> 1 : sum - maxVal
    // return Math.min(sum - maxVal, sum >> 1);
};
// 时间复杂度：O(1)。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
