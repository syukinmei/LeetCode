// 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
// 请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。
// 整数的二进制表示中的 1 就是这个整数的 置位 。
// 例如，21 的二进制表示为 10101 ，其中有 3 个置位。

// 输入：nums = [5,10,1,5,2], k = 1
// 输出：13
// 解释：下标的二进制表示是：
// 0 = 0002
// 1 = 0012
// 2 = 0102
// 3 = 0112
// 4 = 1002
// 下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。
// 因此，答案为 nums[1] + nums[2] + nums[4] = 13 。

// 输入：nums = [4,3,2,1], k = 2
// 输出：1
// 解释：下标的二进制表示是：
// 0 = 002
// 1 = 012
// 2 = 102
// 3 = 112
// 只有下标 3 的二进制表示中存在 k = 2 个置位。
// 因此，答案为 nums[3] = 1 。

// 方法一：模拟
// 枚举所有下标
// 我们直接遍历每个下标 i，判断其二进制表示中 1 的个数是否等于 k，如果等于则将其对应的元素累加到答案 sum 中，最后返回 sum 即可。

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var sumIndicesWithKSetBits = function (nums, k) {
    let sum = 0;
    for (let i = 0; i < nums.length; i++) {
        if (bitCount(i) === k) sum += nums[i];
    }
    return sum;
};

// 辅助函数，统计一个数的二进制位有多少个 1。如 5 的二进制为 101，返回 2。
const bitCount = (n) => {
    let count = 0;
    while (n) {
        n &= n - 1; // 消除二进制末尾的 1
        count++;
    }
    return count;
};
// 时间复杂度：O(n*logn)，n 为 数组 nums 的长度。对于每个下标我们需要 logn 的时间计算它的置位数。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
