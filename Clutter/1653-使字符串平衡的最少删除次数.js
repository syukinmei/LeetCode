// 给你一个字符串 s ，它仅包含字符 'a' 和 'b'​​​​ 。
// 你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i < j ，且 s[i] = 'b' 的同时 s[j]= 'a' ，此时认为 s 是 平衡 的。
// 请你返回使 s 平衡 的 最少 删除次数。

// 输入：s = "aababbab"
// 输出：2
// 解释：你可以选择以下任意一种方案：
// 下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
// 下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。

// 输入：s = "bbaaaaabb"
// 输出：2
// 解释：唯一的最优解是删除最前面两个字符。

/**
 * @param {string} s
 * @return {number}
 */
// 方法一：枚举
// 题意为，在字符串 s 任意位置划一条分割线，删除分割线左侧所有"b"和分割线右侧所有"a"，求最少删除次数即可。
// 用 delA 表示分割线右侧"a"个数，delB 表示分割线左侧"b"个数。delA + delB 即为当前分割线构建平衡字符串需要的删除的字符数。
var minimumDeletions = function (s) {
  // 假定我们删除所有a，此时字符串为全b字符串，符合平衡条件
  let delA = 0; // 记录需要删除的 a 的个数
  for (let c of s) {
    delA += c === "a" ? 1 : 0;
  }
  // 遍历所有分界线可能的位置。
  // 以该分界线为基准需要进行的删除操作为：分界线前b的个数 和 分界线后a的个数
  // delA既是分界线后的a的个数,分界线前b的个数记作 delB
  let delB = 0; // 初始值为0，我们删除了所有 a 没有删除 b
  let ans = delA; // 初始值即为删除所有 a 操作次数
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "a") {
      delA--;
    } else {
      delB++;
    }
    ans = Math.min(ans, delA + delB);
  }
  return ans;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
