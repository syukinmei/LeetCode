// 给你一个字符串 s ，它仅包含字符 'a' 和 'b'​​​​ 。
// 你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i < j ，且 s[i] = 'b' 的同时 s[j]= 'a' ，此时认为 s 是 平衡 的。
// 请你返回使 s 平衡 的 最少 删除次数。

// 输入：s = "aababbab"
// 输出：2
// 解释：你可以选择以下任意一种方案：
// 下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
// 下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。

// 输入：s = "bbaaaaabb"
// 输出：2
// 解释：唯一的最优解是删除最前面两个字符。

/**
 * @param {string} s
 * @return {number}
 */
// 方法一：枚举
// 题意为，在字符串 s 任意位置划一条分割线，删除分割线左侧所有"b"和分割线右侧所有"a"，求最少删除次数即可。
// 用 delA 表示分割线右侧"a"个数，delB 表示分割线左侧"b"个数。delA + delB 即为当前分割线构建平衡字符串需要的删除的字符数。
var minimumDeletions = function (s) {
  // 假定我们删除所有a，此时字符串为全b字符串，符合平衡条件
  let delA = 0; // 记录需要删除的 a 的个数
  for (let c of s) {
    delA += c === "a" ? 1 : 0;
  }
  // 遍历所有分界线可能的位置。
  // 以该分界线为基准需要进行的删除操作为：分界线前b的个数 和 分界线后a的个数
  // delA既是分界线后的a的个数,分界线前b的个数记作 delB
  let delB = 0; // 初始值为0，我们删除了所有 a 没有删除 b
  let ans = delA; // 初始值即为删除所有 a 操作次数
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "a") {
      delA--;
    } else {
      delB++;
    }
    ans = Math.min(ans, delA + delB);
  }
  return ans;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。

// 方法二：动态规划
// 定义 f[i] 表示前 i 个字符中，构建平衡字符串需要删除的最少字符数。初始时 f[0] = 0，答案为 f[n]。
// 遍历字符串 s，维护变量 'countB'，表示遍历到当前位置之前字符串中字符 b 的个数。
//  - 如果当前字符是 b，此时不影响前 i 个字符串的平衡性，因此 f[i] = f[i-1]，countB++。
//  - 如果当前字符是 a，此时我们可以选择删除这个字符 a，那么有 f[i] = f[i-1]+1。（1为删除当前这个 a 的1次操作）
//      亦或是，删除之前的字符 b，那么有 f[i] = b。（将前面的 b 全部删除）
//      因此对于 f[i] 有 f[i] = Math.min(f[i-1]+1, b)。

// 综上所述，我们可以得到状态移动方程：

//          | s[i] = 'b'，f[i] = f[i-1]
//  f[i] = -|
//          | s[i] = 'a'，f[i] = Math.min(f[i-1]+1, b)

// 由于动态规划的求解状态只与前一个状态及变量 b 相关，所以可以使用「滚动数组」进行空间优化。
var minimumDeletions = function (s) {
  let f = 0; // 使用变量 f 维护当前的f[i]，并不需要开辟数组 f
  let countB = 0; //当前位置之前字符串中字符 b 的个数
  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    if (c === "b") {
      countB++; // 更新字符 b 的个数，f 值不变。
    } else {
      f = Math.min(f + 1, countB);
    }
  }
  return f;
};
// 时间复杂度：O(n)，n 为字符串 s 的长度。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
