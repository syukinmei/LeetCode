# 1186.删除一次得到子数组最大和（中等）

[删除一次得到子数组最大和（中等）](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/)

给你一个整数数组，返回它的某个   非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

<br/>

> 示例 1:
> 输入：arr = [1,-2,0,3]
> 输出：4
> 解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。

<br/>

> 示例 2:
> 输入：arr = [1,-2,-2,3]
> 输出：3
> 解释：我们直接选出 [3]，这就是最大和。

<br/>

> 示例 3：
> 输入：arr = [-1,-1,-1,-1]
> 输出：-1
> 解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
> 我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。

<br/>

提示：

- 1 <= arr.length <= $10^5$
- -104 <= arr[i] <= $10^4$

## 方法一：动态规划

##### 1. 定义动态数组的含义

定义 `dp[i][j]` 表示 以第 i 个元素为结尾，删除 j 个元素后的子数组最大和。本题 j 只有 0（不删除元素） 和 1（删除一个元素）的情况。

##### 2. 状态转移方程

思考一下状态转移，对于当前位置 i：

- 如果不删除元素，即 `j = 0`

  - 将第 i 个元素加入到前面的子数组中，此时 `dp[i][0] = dp[i-1][0] + arr[i]`
  - 以第 i 个元素为起点，重新开始一个新的子数组，此时 `dp[i][0] = arr[i]`
  - 综上所述，**`dp[i][0]`** 的状态转移方程为：
    <br/>

    > **dp[i][0] = Math.max(dp[i - 1][0] + arr[i], arr[i]);**

- 如果删除 1 个元素，即 `j = 1`

  - 删除第 i 个元素，此时 `dp[i][1] = dp[i-1][0]`（其之前元素不能删除，题目限制删除 1 次）
  - 不删除第 i 个元素，此时 `dp[i][1] = dp[i-1][1] + arr[i]`
  - 综上所述，**`dp[i][1]`** 的状态转移方程为：
    <br/>

    > **dp[i][1] = Math.max(dp[i - 1][0], dp[i - 1][1] + arr[i]);**

##### 3. 结果

最后，我们需要找到 dp[i][0] 和 dp[i][1] 中的最大值，即为所求的答案。

##### 4. 初始条件

当 `i = 0` 时：

- `dp[0][0]` 表示以第一个元素结尾的子数组不删除元素的最大和。以第一个元素结尾的子数组就是第一个元素本身，不删除元素的最大和显然就是第一个元素本身，即 `dp[0][0] = arr[0]`。

- `dp[0][1]` 表示以第一个元素结尾的子数组删除一个元素后的最大和。以第一个元素结尾的子数组就是第一个元素本身，删除一个元素就是把第一个元素删除得到一个空数组，由于题目限制 **_（删除后）子数组中至少应当有一个元素_** 因此可以将其初始化一个非常小的数，`dp[0][1] = Number.MIN_SAFE_INTEGER`。

- `ans` 的初始是取决 `dp[0][0]` 和 `dp[0][1]` 的最大值，但 `dp[0][1]` 是一个空数组，不合法，仅用于状态转移，因此 `ans = dp[0][0]`，当然也可以取二者最大值，因为我们已经将 `dp[0][1]` 初始为非常小的值了。

##### 代码实现

```js
/**
 * @param {number[]} arr
 * @return {number}
 */
var maximumSum = function (arr) {
  const n = arr.length;
  const dp = new Array(n).fill(0).map(() => [0, 0]);

  // 初始化 dp 数组
  dp[0][0] = arr[0];
  dp[0][1] = Number.MIN_SAFE_INTEGER;
  let ans = arr[0];
  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0] + arr[i], arr[i]);
    dp[i][1] = Math.max(dp[i - 1][0], dp[i - 1][1] + arr[i]);
    ans = Math.max(ans, dp[i][0], dp[i][1]);
  }
  return ans;
};
```

- 时间复杂度：O(n)，n 为数组 arr 的长度，需要遍历一次数组，用于计算动态规划状态。
- 空间复杂度：O(nk)，此题 k 为 2，需要 n \* k 的空间存放状态规划状态个数。

## 空间优化

我们注意到，状态 `dp[i]` 的状态只与 `dp[i-1]` 有关，因此我们可以只使用两个整数来节省空间。
使用 `dp0` 和 `dp1` 来代替 `dp[i][0]` 和 `dp[i][1]` 即可。

此时的状态转移方程为：

- **dp0 = Math.max(dp0 + arr[i], arr[i])**
- **dp1 = Math.max(dp0, dp1 + arr[i])**

注意：

`dp0` 的状态转移仅与 `dp0` 有关，而 `dp1` 的状态与 `dp0、dp1` 都有关，因此需要 **先更新 `dp1` 再更新 `dp0`，避免 `dp0` 更新后 `dp1` 再更新使用了错误的状态**。
