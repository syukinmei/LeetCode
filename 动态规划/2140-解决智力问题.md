# 2140.解决智力问题（中等）

[解决智力问题(中等)](https://leetcode.cn/problems/solving-questions-with-brainpower/description/)

给你一个下标从 **0** 开始的二维整数数组 `questions` ，`其中 questions[i] = [points_i, brainpower_i]` 。

这个数组表示一场考试里的一系列题目，你需要 **按顺序** （也就是从问题 0 开始依次解决），针对每个问题选择 **解决** 或者 **跳过** 操作。解决问题 `i` 将让你 **获得** `points_i` 的分数，但是你将 **无法** 解决接下来的 `brainpower_i` 个问题（即只能跳过接下来的 `brainpower_i` 个问题）。如果你跳过问题 `i` ，你可以对下一个问题决定使用哪种操作。

-   比方说，给你 `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]` ：
    -   如果问题 `0` 被解决了， 那么你可以获得 `3` 分，但你不能解决问题 `1` 和 `2` 。
    -   如果你跳过问题 `0` ，且解决问题 `1` ，你将获得 `4` 分但是不能解决问题 `2` 和 `3` 。

请你返回这场考试里你能获得的 **最高** 分数。

<br/>

> 示例 1:
> 输入：questions = [ [3,2],[4,3],[4,4],[2,5] ]
> 输出: 5
> 解释：解决问题 0 和 3 得到最高分。
>
> -   解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。
> -   不能解决问题 1 和 2
> -   解决问题 3 ：获得 2 分
>     总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。

<br/>

> 示例 2:
> 输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
> 输出：7
> 解释：解决问题 1 和 4 得到最高分。
>
> -   跳过问题 0
> -   解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。
> -   不能解决问题 2 和 3
> -   解决问题 4 ：获得 5 分
>     总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。

<br/>

提示：

-   0 <= questions.length <= $10^5$
-   questions[i].length == 2
-   1 <= points_i, brainpower_i <= $10^5$

## 方法一：动态规划

这道题是力扣 [198.打家劫舍](https://leetcode.cn/problems/house-robber/description/) 的变形题，如果选 `questions[i]`，那么接下来的 `brainpower_i` 个问题都不能选。打家劫舍那题相当于 `brainpower_i = 1`。

例如示例 1，我们要解决的（原问题）是剩余问题的下标为`[0, 3]`，求这些问题中可获取的最大分数。
讨论 `questions[0]` **选或不选**：

-   如果不选，子问题为：剩余问题的下标为`[1, 3]`，求这些问题中可获取的最大分数。
-   如果选，解析来的 `2` 个问题都不选，子问题为：剩余问题的下标为`[3, 3]`，求这些问题中可获取的最大分数。

由于选或不选都会把原问题变成一个**和原问题相似的、规模更小的子问题**，所以可以用动态规划解决。

##### 1.定义动态数组的含义

定义状态 `dp[i]` 表示从第 `i` 个问题到最后一个问题可获得的最大分数。

##### 2.状态移动方程

对于每个问题 `i` ，我们都有两种选择：

-   解决当前问题

    -   获得 `points_i` 分
    -   跳过接下来的 `brainpower_i` 个问题
    -   下一个可解的问题为 `i + brainpower_i + 1`
    -   这部分的分数为 `points_i + dp[i + brainpower_i + 1]`

-   跳过当前问题
    -   不得分
    -   下一个可解的问题为 `i + 1`
    -   这部分的分数为 `dp[i + 1]`

因此状态转移方程为：
**`dp[i] = max(points_i + dp[i + brainpower_i + 1], dp[i + 1])`**

> 注意 `i + brainpower_i + 1` 超过问题总数时的边界判断。

##### 3.结果

最终答案即：`dp[0]` 从第 `1` 个问题开始到最后一个问题可获得的最大分数。

##### 4.初始条件

`n` 问题数量

`dp[n] = 0`，即当 `i` 等于问题数量 `n` 时，没有更多问题可解，得分为 `0`。

dp 数组初始化长度为 `n + 1`，初始值填充为 `0`。

##### 代码实现

```js
/**
 * @param {number[][]} questions
 * @return {number}
 */
var mostPoints = function (questions) {
    // step1：定义并初始化dp数组
    // dp[i] 表示从第 i 个问题到最后一个问题可获得的最大分数
    const n = questions.length;
    const dp = new Array(n + 1).fill(0);

    // step2：状态移动方程，从数组末尾往前开始遍历，进行状态移动
    for (let i = n - 1; i >= 0; i--) {
        const [points, brainpower] = questions[i];
        const next = i + brainpower + 1;

        dp[i] = Math.max(points + (next < n ? dp[next] : 0), dp[i + 1]);
    }

    //  step3：返回答案 dp[0] 即为解决这一系列题目可获得的最高得分
    return dp[0];
};
```

-   时间复杂度：O($n$)，n 为数组 questions 的长度，动态规划的时间 = 状态个数 \* 单个状态的计算时间。本题状态个数为 O(n)，单个状态的计算时间为 O($1$)，因此时间复杂度为 O($n$)。
-   空间复杂度：O($n$)，n 为数组 questions 的长度，需要使用长度为 n 的 dp 数组来存放状态规划状态个数。
