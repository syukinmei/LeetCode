# 1696.跳跃游戏 VI（中等）

[跳跃游戏 VI（中等）](https://leetcode.cn/problems/jump-game-vi/description/)

给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。

一开始你在下标 `0` 处。每一步，你最多可以往前跳 `k` 步，但你不能跳出数组的边界。也就是说，你可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]` **包含** 两个端点的任意位置。

你的目标是到达数组最后一个位置（下标为 `n - 1` ），你的 **得分** 为经过的所有数字之和。

请你返回你能得到的 **最大得分**。

> 示例 1：
> 输入：nums = [1,-1,-2,4,-7,3], k = 2
> 输出：7
> 解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。

<br/>

> 示例 2：
> 输入：nums = [10,-5,-2,4,0,3], k = 3
> 输出：17
> 解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。

<br/>

> 示例 3：
> 输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
> 输出：0

<br/>

提示：

-   1 <= nums.length, k <= 10^5
-   -10^4 <= nums[i] <= 10^4

## 方法一：动态规划+单调双端队列

到达最后一个位置 `x`，可以通过位置 `x-1`、`x-2`、... 、 `x-k` 跳跃到达。因此到达位置 `x` 的得分可能是位置 `x` 的得分加上到达位置 `x-1`、`x-2`、... 、 `x-k` 任意一个位置的得分。
为了使到达 `x` 的得分最大，应该选择到达位置 `x-1`、`x-2`、... 、 `x-k` 中最大的得分来进行跳跃。
同理，位置 `x-1`、`x-2`、... 、 `x-k` 这些位置的最大得分也可以通过前 `k` 个位置的最大的分推断。

我们每一步可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]`，因此到达下标的最大得分可以从其之前 `[max(0, i - k), i - 1]` 的任意位置转移过来。

**即到达每个位置的最大得分为前面 `k` 步的最大得分，再加上当前位置的得分得到。** 由此我们可以想到动态规划来解决这个问题

#### 1.定义动态数组的含义

**定义 `dp[i]` 表示到达位置 `i` 的最大得分。**

那么我们的求解也就是 `dp[n - 1]`，即到达最后一个位置的最大得分。

#### 2.状态移动方程

这表示到达位置 `i` 的最大得分是当前位置的得分 `nums[i]` 加上前面 `k` 个位置的最大得分中的最大值。

**`dp[i] = nums[i] + max(dp[i-1], dp[i-2], ..., dp[i-k])`**
**`dp[i] = nums[i] + max(dp[j]) , j ∈ [i - k, i - 1]`**

需要注意边界，必须是有效值 **max(0, i - k), min(n - 1, i - 1)**

#### 3.初始状态

当 `i = 0` 时，`nums[0]` 既是它的最大得分。因此 `dp[0] = nums[0]` ，表示从索引 `0` 出发，当前的最大得分为其本身。

#### 4.优化 - 单调双端队列（滑动窗口）

由于每个状态我们都需要枚举其前面 `k` 个状态找到其中最大值，时间复杂度为 `O(nk)`。因此我们需要一种方法快速找到其前 `k` 个状态的最大值。

这就想到了另一道题 [239.滑动窗口最大值（困难）](https://leetcode.cn/problems/sliding-window-maximum/description/)，引入 **单调双端队列**。

我们要找到每个位置 `i` 前面 `k` 个位置的最大值，相当于维护一个长度为 `k` 的滑动窗口，每次返回窗口中的最大值。
而这个滑动窗口就是 **「队首到队尾逐渐递减」的双端队列** 。队首即 `[i - k, i - 1]` 的最大值。

窗口每次滑动的时候，需要从队首中将不在 `[i-k, i-1]` 的元素出队淘汰。从队尾中加入新的未来可能成为最大值的元素。

##### 滑动窗口为什么存储的索引

在进行状态推移（每一步跳跃）的时候，需要保证窗口中的元素在范围 `[i - k, i -1]` 内。通过存储索引而不是值，可以在更新滑动窗口状态的时候更加方便。同时，存储索引可以帮助我们在状态推移时直接访问原数组，而不必通过值来查找对应的位置。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxResult = function (nums, k) {
    const n = nums.length;

    // 创建 dp 数组，dp[i] 表示到达位置 i 的最大得分。
    const dp = new Array(n).fill(0);

    // 初始化 dp 数组
    dp[0] = nums[0];

    // 使用「单调递减的双端队列」来保存可能的最大得分的位置。为了取值方便(存放窗口中值的下标)。
    const query = new Array();
    query.push(0);

    // 状态推移
    for (let i = 1; i < n; i++) {
        // 判断当前最大值（即队首元素）是否在窗口中，若不在便将其出队(队首值的下标小于i-k)
        if (query.length && query[0] < i - k) {
            query.shift();
        }

        // 获取当前位置的最大得分
        dp[i] = nums[i] + dp[query[0]];

        // 保持窗口单调递减，若队列有值 且 队尾所存下标的元素小于等于当前元素，则弹出队尾(队尾元素 <= 当前元素，则弹出队列)
        while (query.length && dp[query[query.length - 1]] <= dp[i]) {
            query.pop();
        }

        // 新元素入队
        query.push(i);
    }

    // dp[n - 1] 即到达最后一个位置的最大得分。
    return dp[n - 1];
};
```

-   时间复杂度：O($n$)，n 为数组 nums 的长度，动态规划的时间 = 状态个数 \* 单个状态的计算时间。本题状态个数为 O(n)，计算每个状态的时候需要进行双端队列的操作，由于每个元素最多入队和出队一次，因此单个状态的计算时间为 O(1)，总的时间复杂度为 O($n$)。

-   空间复杂度：O(n+k)，n 为数组 nums 的长度，需要使用长度为 n 数组 dp 来存放状态规划状态个数，以及一个最多存储 k 个元素的双端队列。因此总的空间消耗为 O(n+k)。
