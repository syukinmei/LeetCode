# 1289.下降路径最小和 II（困难）

[下降路径最小和 II(困难)](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)

给你一个 `n x n` 整数矩阵 `grid` ，请你返回 非零偏移下降路径 数字和的最小值。

非零偏移下降路径 定义为：从 `grid` 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

![示例1:](https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg)

> 示例 1：
> 输入：grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]
> 输出：13
> 解释：
> 所有非零偏移下降路径包括：
> [1,5,9], [1,5,7], [1,6,7], [1,6,8],
> [2,4,8], [2,4,9], [2,6,7], [2,6,8],
> [3,4,8], [3,4,9], [3,5,7], [3,5,9]
> 下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。

<br/>

> 示例 2：
> 输入：grid = [ [7] ]
> 输出：7

<br/>

提示：

- n == grid.length == grid[i].length
- 1 <= n <= 200
- -99 <= grid[i][j] <= 99

## 方法一：动态规划

此题是力扣 [931.下降路径最小和(中等)](https://leetcode.cn/problems/minimum-falling-path-sum/) 的升级版。

根据题意，我们可以发现以下特点：

- 每个位置的最小路径和依赖于上一行各个位置的最小路径和。
- 每个位置的最小路径和等于上一行非同列的位置最小路径和加上当前位置的值。

基于上述，我们可以使用动态规划来解决这个问题。
定义 `dp[i][j]` 表示从第一行开始下降，到达位置 `(i, j)` 的最小路径和。而 `dp[i][j]` 只能从上一行的非 `(i-1, j)` 的 k 个位置转移过来，因此状态移动方程为：

**`dp[i][j] = grid[i][j] + min(dp[i - 1][k])`** k !== j

最终答案在于最后一行中，`dp[n]` 中的最小值，即：**`min(...dp[n - 1])`**

⚠️ 注意：

1. 对于第一行 `(i = 0)` 的下降路径最小和就是元素本身，因此 `dp[0][j] = grid[0][j]` 。

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minFallingPathSum = function (grid) {
  // 创建一个 n * n 的二位数组，初始值为无穷大，用于存储最小路径和
  const n = grid.length;
  const dp = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));

  // 初始化第一行的最小路径和，为对应位置的矩阵值
  for (let i = 0; i < n; i++) {
    dp[0][i] = grid[0][i];
  }

  // 从第二行开始计算最小路径和
  for (let i = 1; i < n; i++) {
    // 遍历 i 行的每一个位置
    for (let j = 0; j < n; j++) {
      // 求位置 (i, j) 的下降路径最小和
      for (let k = 0; k < n; k++) {
        if (k === j) continue; // 不允许非零偏移下降，如果当前列和上一行的列相同，则跳过
        dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + grid[i][j]); // 更新位置 (i, j) 的最小路径和
      }
    }
  }

  // 返回最后一行的最小路径和中的最小值，即为答案
  return Math.min(...dp[n - 1]);
};
```
- 时间复杂度：O($n^3$)，n 为 grid 的边长，需要遍历整个矩阵，并计算每个位置的最小路径和。
- 空间复杂度：O($n^2$)，需要使用 n * n 的二位数组 dp 来保存状态。
