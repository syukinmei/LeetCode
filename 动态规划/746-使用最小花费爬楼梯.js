// 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

// 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

// 请你计算并返回达到楼梯顶部的最低花费。

// 输入：cost = [10,15,20]
// 输出：15
// 解释：你将从下标为 1 的台阶开始。
// - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
// 总花费为 15 。

// 输入：cost = [1,100,1,1,1,100,1,1,100,1]
// 输出：6
// 解释：你将从下标为 0 的台阶开始。
// - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
// - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
// - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
// - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
// 总花费为 6 。

// 方法一：动态规划
// 1、定义动态数组含义
//   定义 dp[i] 表示到达第 i 个楼梯的最小花费。
// 2、状态转移方程
//   对于每个楼梯 i ，可以选择从前一级直接跨一步，或者从前两级楼梯跨两步，因此，动态规划方程为：
//   dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
// 3、初试条件
//   由于可以选择下标 0 或 1 作为初始阶梯，因此有 dp[0] = 0 和 dp[1] = 0，表示起始位置的话费为 0。
// 4、结果
//   最终答案为 dp[n]，即到达顶部的最小花费。
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function (cost) {
    const n = cost.length;
    const dp = new Array(n + 1);
    dp[0] = dp[1] = 0;

    for (let i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
};
// 时间复杂度：O(n)，n 为数组 const 的长度，遍历整个楼梯，用于计算动态规划状态。
// 空间复杂度：O(n)，额外使用了大小为 n+1 的数组来存储动态规划结果。

// 方法二：滚动数组优化
// 我们可以注意到，当 i >= 2时，dp[i] 只和 dp[i-1] 于 dp[i-2] 有关，因此我们可以使用滚动数组的思想，将空间复杂度优化到 O(1)。
var minCostClimbingStairs = function (cost) {
    const n = cost.length;
    let prev = 0, // 到达前 2 级楼梯的最小花费
        curr = 0; // 到达前 1 级楼梯的最小花费
    for (let i = 2; i <= n; i++) {
        let next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);
        prev = curr;
        curr = next;
    }
    return curr;
};
// 时间复杂度：O(n)，n 为数组 cost 的长度，遍历整个楼梯，用于计算动态规划状态。
// 空间复杂度：O(1)，使用滚动数组的思想，只需要常数的空间存放若干变量。
