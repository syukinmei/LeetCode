# 799.特殊数组 II（中等）

[特殊数组 II(中等)](https://leetcode.cn/problems/special-array-ii/description/)

如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 **特殊数组** 。

你有一个整数数组 `nums` 和一个二维整数矩阵 `queries`，对于 `queries[i] = [from_i, to_i]`，请你帮助你检查子数组 `nums[from_i..to_i]` 是不是一个 **特殊数组** 。

返回布尔数组 `answer`，如果 `nums[from_i..to_i]` 是特殊数组，则 `answer[i]` 为 `true` ，否则，`answer[i]` 为 `false` 。

<br/>

> 示例 1:
> 输入: nums = [3,4,1,2,6], queries = [[0,4]]
> 输出: [false]
> 解释: 子数组是 [3,4,1,2,6]。2 和 6 都是偶数。

<br/>

> 示例 2:
> 输入: nums = [4,3,1,6], queries = [[0,2],[2,3]]
> 输出: [false,true]
> 解释:
>
> 1. 子数组是 [4,3,1]。3 和 1 都是奇数。因此这个查询的答案是 false。
> 2. 子数组是 [1,6]。只有一对：(1,6)，且包含了奇偶性不同的数字。因此这个查询的答案是 true。

<br/>

提示：

- 1 <= nums.length <= $10^5$
- 1 <= nums[i] <= $10^5$
- 1 <= queries.length <= $10^5$
- queries[i].length == 2
- 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1

## 前置：

在判断两个元素奇偶性是否相同时，可以利用位运算来解决，对于给定的元素 `a, b`，利用 **(a ^ b) & 1** 检查 `a` 和 `b` 异或结果的最低位是否为 `1`。这能告诉我们 `a` 和 `b` 在最低位（即奇偶性相关的位）是否不同，为 `0` 意味着最低位上是相同的（即要么都是偶数，要么都是奇数），为 `1` 意味着它们在最低位上不同（一个奇数，一个偶数）。
因此， **(a ^ b) & 1 === 1** 时，`a, b` 的奇偶性不同，否则相同。

## 方法一：模拟

### 解题思路

最直接的方法是根据题意分别计算每个查询区间 `queries[i]` 是否为特殊数组，此时需要的时间复杂度为 **O(n^2)**。

## 方法一：动态规划

对于任意的特殊数组 `nums[i, ...,j]` ，其任意的连续子数组也一定是特殊数组，因此我们只需要检测以 `j` 为结尾的最长特殊数组是否覆盖区间 `[i, j]` 即可。

因此，我们可以选使用动态规划来求解，具体的：

##### 1.定义动态数组的含义

**定义 `dp[i]` 表示以 `i` 为结尾的最长特殊数组的长度。**

##### 2.状态移动方程

- 如果 `nums[i]` 与左边相邻的元素 `nums[i - 1]` 的奇偶性相同，有 `dp[i] = 1`。

- 如果 `nums[i]` 与左边相邻的元素 `nums[i - 1]` 的奇偶性不同，此时 `nums[i]` 可以追加到以 `nums[i-1]` 为结尾的最长特殊数组的后面，有 `dp[i] = dp[i - 1] + 1`。

##### 3.结果

对于每个查询 `queries[i] = [from_i, to_i]`，我们只需要判断 `dp[to_i]` 是否大于等于 `to_i - from_i + 1` 即可。

##### 4.初始条件

`dp[i]` 所有元素置 `1` ，表示每个元素都只能和自己组成一个长度为 `1` 的特殊数组。

##### 代码实现

```js
/**
 * @param {number[]} nums
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var isArraySpecial = function (nums, queries) {
  // step1：定义并初始化状态转移方程
  const n = nums.length;
  const dp = new Array(n).fill(1);

  // step2：状态移动方程
  for (let i = 1; i < n; i++) {
    // 判断两数最低位是否不同，不同即奇偶性不同
    if ((nums[i] ^ nums[i - 1]) & 1) {
      dp[i] = dp[i - 1] + 1;
    }
  }

  // step3：判断每次查询
  const res = [];
  for (const [from, to] of queries) {
    const flag = dp[to] >= to - from + 1; // 判断以 nums[to] 为结尾的
    res.push(flag);
  }

  return res;
};
```

- 时间复杂度：O($n+m$)，n 为数组 nums 的长度，m 为查询数组 queries 的长度，分别需要对其进行一次遍历，以进行状态移动和查询。
- 空间复杂度：O($n$)，n 为数组 nums 的长度，需要使用长度为 n 的 dp 数组来存放状态规划状态个数。
