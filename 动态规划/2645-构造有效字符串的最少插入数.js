// 给你一个字符串 word ，你可以向其中任何位置插入 "a"、"b" 或 "c" 任意次，返回使 word 有效 需要插入的最少字母数。
// 如果字符串可以由 "abc" 串联多次得到，则认为该字符串 有效 。

// 输入：word = "b"
// 输出：2
// 解释：在 "b" 之前插入 "a" ，在 "b" 之后插入 "c" 可以得到有效字符串 "abc" 。

// 输入：word = "aaa"
// 输出：6
// 解释：在每个 "a" 之后依次插入 "b" 和 "c" 可以得到有效字符串 "abcabcabc" 。

// 输入：word = "abc"
// 输出：0
// 解释：word 已经是有效字符串，不需要进行修改。

// 提示:
// 1 <= word.length <= 50
// word 仅由字母 "a"、"b" 和 "c" 组成。

// 方法一：动态规划
// 1、定义动态数组含义
//   定义 dp[i] 表示 word[0,j] 部分变成有效字符串所需要的最小插入次数
// 2、状态转移方程
//   对于当前位置 word[i] 无非就2种情况：
//   单独存在于一组 abc 中，即当前字符 <= 前一个字符的情况，需插入 2 个字母以保持递增顺序。 
//      - 则 dp[i] = dp[i-1] +2
//   可以和前一个字符纳为同一组，即当前字符 > 前一个字符串的情况。只需要在当前字符串前或后插入 1 个字母可组成 abc。
//      - 则 dp[i] = dp[i-1] +1
//             |- word[i] <= word[i - 1]， dp[i-1] +2
//    dp[i] = -
//             |- word[i] > word[i - 1]， dp[i-1] +1
// 
// 3、初试条件
//   但只要一个字母时，显而易见无论字母为什么，都需要插入另外 2 个字母以保持递增顺序。
// 4、结果
//   最终答案为 dp[n-1]，字符串最后一个位置的最小插入次数即为答案。
/**
 * @param {string} word
 * @return {number}
 */
var addMinimum = function (word) {
  const n = word.length;

  // 创建一个数组 dp 用于存储每个位置的最小插入次数。
  // dp[i] 表示 word[0,j] 部分最小插入次数
  const dp = new Array(n).fill(0);

  // 将 dp[0] 初始化为 2，无论是 'a'、'b'、'c' 中的任意一个，都需要插入 2 个字母以保持递增顺序。
  dp[0] = 2;

  // 从第 2 个字符开始遍历字符串，进行状态移动
  for (let i = 1; i < n; i++) {
    // 单独存在于一组 abc 中，需插入 2 个字母以保持递增顺序
    if (word[i] <= word[i - 1]) {
      dp[i] = dp[i - 1] + 2;
    } else {
      // 如果当前字母大于前一个字母，即形成 'ac'、'bc'、'ab' 则可以将他们纳为同一组
      dp[i] = dp[i - 1] - 1;
    }
  }

  // 字符串最后一个位置的最小插入次数，即为答案。
  return dp[n - 1];
};
// 时间复杂度：O(n)，n 为字符串 word 的长度，遍历整个字符串，用于计算动态规划状态。
// 空间复杂度：O(n)，需要一个长度为 n 的数组来存储动态规划结果。


// 由于每一个位置的的最小插入次数只与上一个位置的最小插入次数有关，因此我们可以使用滚动数组的方式优化空间复杂度至 O(1)。