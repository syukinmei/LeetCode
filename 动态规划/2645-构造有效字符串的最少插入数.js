// 给你一个字符串 word ，你可以向其中任何位置插入 "a"、"b" 或 "c" 任意次，返回使 word 有效 需要插入的最少字母数。
// 如果字符串可以由 "abc" 串联多次得到，则认为该字符串 有效 。

// 输入：word = "b"
// 输出：2
// 解释：在 "b" 之前插入 "a" ，在 "b" 之后插入 "c" 可以得到有效字符串 "abc" 。

// 输入：word = "aaa"
// 输出：6
// 解释：在每个 "a" 之后依次插入 "b" 和 "c" 可以得到有效字符串 "abcabcabc" 。

// 输入：word = "abc"
// 输出：0
// 解释：word 已经是有效字符串，不需要进行修改。

// 提示:
// 1 <= word.length <= 50
// word 仅由字母 "a"、"b" 和 "c" 组成。

// 方法一：动态规划
// 1、定义动态数组含义
//   定义 dp[i] 表示 word[0,j] 部分变成有效字符串所需要的最小插入次数
// 2、状态转移方程
//   
// 3、初试条件
//   
// 4、结果
//   最终答案为 dp[n-1]，字符串最后一个位置的最小插入次数即为答案。
/**
 * @param {string} word
 * @return {number}
 */
var addMinimum = function (word) {
  const n = word.length;

  // 创建一个数组 dp 用于存储每个位置的最小插入次数。
  // dp[i] 表示 word[0,j] 部分最小插入次数
  const dp = new Array(n).fill(0);

  // 将 dp[0] 初始化为 2，无论是 'a'、'b'、'c' 中的任意一个，都需要插入 2 个字母以保持递增顺序。
  dp[0] = 2;

  // 从第 2 个字符开始遍历字符串，进行状态移动
  for (let i = 1; i < n; i++) {
    // 单独存在于一组 abc 中，需插入 2 个字母以保持递增顺序
    if (word[i] <= word[i - 1]) {
      dp[i] = dp[i - 1] + 2;
    } else {
      // 如果当前字母大于前一个字母，即形成 'ac'、'bc'、'ab' 则可以将他们纳为同一组
      dp[i] = dp[i - 1] - 1;
    }
  }

  // 字符串最后一个位置的最小插入次数，即为答案。
  return dp[n - 1];
};
// 时间复杂度：O(n)，n 为字符串 word 的长度，遍历整个字符串，用于计算动态规划状态。
// 空间复杂度：O(n)，需要一个长度为 n 的数组来存储动态规划结果。
