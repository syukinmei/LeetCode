# 2266.统计打字方案数（中等）

[统计打字方案数（中等）](https://leetcode.cn/problems/count-number-of-texts/description/)

Alice 在给 Bob 用手机打字。数字到字母的 **对应** 如下图所示。

![手机按键图](https://pic.leetcode.cn/1722224025-gsUAIv-image.png)

为了 **打出** 一个字母，Alice 需要 **按** 对应字母 `i` 次，`i` 是该字母在这个按键上所处的位置。

-   比方说，为了按出字母 `'s'` ，Alice 需要按 `'7'` 四次。类似的， Alice 需要按 `'5'` 两次得到字母 `'k'` 。
-   注意，数字 `'0'` 和 `'1'` 不映射到任何字母，所以 Alice **不** 使用它们。

但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 **按键的字符串信息** 。

-   比方说，Alice 发出的信息为 `"bob"` ，Bob 将收到字符串 `"2266622"` 。

给你一个字符串 `pressedKeys` ，表示 Bob 收到的字符串，请你返回 Alice **总共可能发出多少种文字信息** 。

由于答案可能很大，将它对 `109 + 7` **取余** 后返回。

<br/>

> 示例 1:
> 输入：pressedKeys = "22233"
> 输出：8
> 解释：
> Alice 可能发出的文字信息包括：
> "aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae" 和 "ce" 。
> 由于总共有 8 种可能的信息，所以我们返回 8 。

<br/>

> 示例 2:
> 输入：pressedKeys = "222222222222222222222222222222222222"
> 输出：82876089
> 解释：
> 总共有 2082876103 种 Alice 可能发出的文字信息。
> 由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。

<br/>

提示：

-   1 <= pressedKeys.length <= $10^5$
-   pressedKeys 只包含数字 '2' 到 '9' 。

## 方法一：动态规划 + 按键分段

> 通过动态规划预处理连续按键的组合数，我们可以在遍历 pressedKeys 时，通过分割连续相同字符的子串并计算每个部分的组合数，最终得到总的组合数。利用乘法原理和模运算，得到了最终的正确答案。

由于连续相同的数字，会有多种组合方式：
例如 `"2"`，它可以映射 `"a"` 或 `"b"` 或 `"c"`；

我们可以将字符串分解为多个部分（连续相同字符），每个部分由相同的字符组成，且相邻两个部分的字符不一样，计算该部分的所有可能组合数。那么，根据乘法原理，**构成文字信息的总方案数等于这些部分各自对应方案数的乘积**。

对于某个特定字符组成的子串，其方案数仅与 **子串的长度和字符对应的字母种类数** 有关。

那么，对于每一部分有多少种组合方式呢？
假设某一部分是数组 `2` 构成的子串，长度为 `n`：

-   如果最后一个字母拆出来，得到 `"a"`，那么这种情况有多少种组合方式，就 **取决于之前长度 n-1 的子串有多少种组合方式**；
-   如果最后两个字母拆出来，得到 `"b"`，那么这种情况有多少种组合方式，就 **取决于之前长度 n-2 的子串有多少种组合方式**；
-   如果最后三个字母拆出来，得到 `"c"`，那么这种情况有多少种组合方式，就 **取决于之前长度 n-3 的子串有多少种组合方式**；

可以看到，我们原本求长度为 n 的子串组合数量，变成了三个规模更小的子问题：长度为 n-1，n-2，n-3 的子串组合数量。

因此计算某个连续相同字符的组合方式可以使用动态规范来解决。

##### 1.定义动态数组的含义

记 dp_3[i] 表示长度为 `i` 的子串组合方式数量（连续按多次 3 个字母按键对应的方案数）。
由于数字 `"7"` 和 `"9"` 对应的字母种类数为 4，因此可以用 dp_4[i] 表示长度为 `i` 的子串组合方式数量（连续按多次 4 个字母按键对应的方案数）。

##### 2.状态移动方程

**`dp_3[i] = dp_3[i-1] + dp_3[i-2] + dp_3[i-3]`**
**`dp_4[i] = dp_4[i-1] + dp_4[i-2] + dp_4[i-3] + dp_4[i-4]`**

推导的时候需要注意下标是否越界。

##### 3.结果

对于某个连续相同字符，其组合方式数量为：
如果字符为 `"7"` 或 `"9"`，那么结果为 `dp_4[n]`；否则结果为 `dp_3[n]`。

##### 4.初始条件

dp_3 = [0, 1, 2, 4]
dp_4 = [0, 1, 2, 4]

> 2 = abc
> 2=> a
> 22=> aa、b
> 222=> aaa、ab、ba、c
> 2222=> aaaa、aab、aba、ac、baa、bb、ca

> 7 = pqra
> 7=> p
> 77=> pp、q
> 777=> ppp、pq、qr、r
> 7777=> pppp、ppq、pqr、prq、qpr、rqp、rrp、qq、ra、ar、rp、qa、aq、qr、rq、rr

##### 代码实现

```javascript
/**
 * @param {string} pressedKeys
 * @return {number}
 */
var countTexts = function (pressedKeys) {
    const MOD = 10 ** 9 + 7;
    const n = pressedKeys.length;
    const dp_3 = [0, 1, 2, 4]; // 连续按多次 3 个字母按键对应的方案数
    const dp_4 = [1, 1, 2, 4]; // 连续按多次 4 个字母按键对应的方案数

    // 通过动态规划预先计算所有可能的组合数
    for (let i = 4; i <= n; i++) {
        dp_3[i] = (dp_3[i - 1] + dp_3[i - 2] + dp_3[i - 3]) % MOD;
        dp_4[i] = (dp_4[i - 1] + dp_4[i - 2] + dp_4[i - 3] + dp_4[i - 4]) % MOD;
    }

    let ans = BigInt(1); // 总方案数，题目 pressedKeys 至少为 1，因此最少一种方案
    let cnt = 0; // 当前字符连续出现的次数

    // 遍历 pressedKeys ，按键划分，将相同连续字符进行划分，计算每部分有多少种组合方式，然后根据乘法原理更新总方案数。
    for (let i = 0; i < n; i++) {
        const c = pressedKeys[i]; // 当前字符
        cnt++; // 增加当前字符的连续计数
        // 如果遍历到最后一个字符 或 当前字符与下一个字符不同，则进行处理
        if (i === n - 1 || c !== pressedKeys[i + 1]) {
            // 如果字符是 '7' 或 '9'，使用 dp_4 进行计算，否则使用 dp_3 进行计算
            const curCount =
                c !== "7" && c !== "9" ? BigInt(dp_3[cnt]) : BigInt(dp_4[cnt]); // 当前子串的组合方式数
            ans = (ans * curCount) % BigInt(MOD); // 更新总方案数：累乘当前部分的组合数
            cnt = 0; // 重置计数器，准备统计下一个连续相同字符子串
        }
    }

    return Number(ans); // 返回最终的结果（转为数字返回）
};
```

-   时间复杂度：O($n$)，n 为数组 pressedKeys 的长度，初始化 dp_3 和 dp_4 数组的时间复杂度是 O(n)，遍历字符串 pressedKeys 时进行按键划分和计算总方案数的时间复杂度为 O(n)，总的时间复杂度为 O($n$)。

-   空间复杂度：O(n)，n 为数组 pressedKeys 的长度，需要使用两个长度为 n 数组 dp 来存放状态规划状态个数，因此总的空间消耗为 O(n)。
