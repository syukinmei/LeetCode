# 300.最长递增子序列（中等）

[最长递增子序列(中等)](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

<br/>

> 示例 1:
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

<br/>

> 示例 2:
> 输入：nums = [0,1,0,3,2,3]
> 输出：4

<br/>

> 示例 3:
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1

<br/>

提示：

-   1 <= nums.length <= 2500
-   -$10^4$ <= nums.length <= $10^4$

## 方法一：动态规划

根据题意分析，如果一个较大的数字接在较小数字的后面，就会形成一个更长的子序列。因此，只要 `nums[i]` 严格大于在它位置之前的某个数，那么 `nums[i]` 就可以接在这个数字后面形成一个更长的递增子序列。

##### 1.定义状态数字的含义

`dp[i]` 表示 `nums` 以 `nums[i]` 作为结尾时，最长递增子序列的长度。

##### 2.状态移动方程

根据题意，我们很容易得到状态转移方程：
设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：

-   如果 `nums[i] > nums[j]` ，那么 `nums[i]` 可以接在 `nums[j]` 后面，`dp[i] = max(dp[i], dp[j] + 1)` 。

-   如果 `nums[i] <= nums[j]` ，那么 `nums[i]` 不能接在 `nums[j]` 后面，`dp[i] = dp[i]` 。

综上所属，我们需要计算出 `dp[i]` 的最大值需要遍历 `j`，每轮执行 `dp[i] = max(dp[i], dp[j] + 1)`

> **dp[i] = Math.max(dp[i], dp[j] + 1) for j of [0, i)**

##### 3.返回值

最后一个状态值只表示以 `nums[len - 1]` 结尾的最长递增子序列的长度，状态数组 `dp` 的最大值才是全局的最长递增子序列的长度。

因此，最终答案为：dp 数组最大值 `max(...dp)`，即为全局的最长递增子序列的长度。

##### 4.初始化状态数组

`dp[i]` 所有元素置 `1`，含义是每个元素都至少可以单独成为子序列，此时长度都为 `1`。

##### 代码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
    const n = nums.length;
    // step1：定义并初始化状态转移方程
    // 创建 dp 数组，dp[i] 表示以 nums[i] 作为结尾时，最长递增子序列的长度。
    const dp = new Array(n).fill(1);

    // step2：状态推移
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            // 寻找新的递增子序列的头，并更新 dp[i] 。
            if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

    // step3：返回答案，max(...dp) 即为数组 nums 的最长递增子序列的长度
    return Math.max(...dp);
};
```

-   时间复杂度：O($n^2$)，n 为数组 nums 的长度，动态规划的时间 = 状态个数 \* 单个状态的计算时间。本题状态个数为 O(n)，对于每个状态需要遍历 dp[0...i-1] 的所有状态，因此单个状态的计算时间为 O(n)，总的时间复杂度为 O($n^2$)。
-   空间复杂度：O($n$)，n 为数组 nums 的长度。需要使用长度为 n 数组 dp 来存放状态规划状态个数。

> tips：遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。

<br/>

## 方法二：贪心 + 二分

方法一的时间复杂度为 O($n^2$)，能否优化？

**优化思路：**

-   动态规划中，通过线性遍历来计算 dp 的复杂度是无法降低的。
-   方法一的时间复杂度为 O($n^2$)，是因为每次计算 dp[i] 时，需要遍历 [0, i) 列表区间，计算 dp[i] 的最大值。能否只遍历一次，就能计算出 dp[i] 的最大值？
-   我们考虑是否可以通过重新定义动态数组的含义，来减少单个状态的计算时间呢？
-   对于动态规划问题，如果想去优化时间复杂度的话，可以使用其进阶技巧 **交换状态与状态值**

> 方法一中： dp[i] 表示**末尾元素**为 nums[i] 的最长递增子序列**长度**。
> 改为： dp[i] 表示**长度**为 i+1 的递增子序列的**末尾元素**的最小值。

-   即：我们重新定义动态数组的含义，将 `dp[i]` 定义为：长度为 `i+1` 的递增子序列的末尾元素的最小值。

使用最小值是因为：对于一个常量数字 `N` 和一个随机数 `x`，我们可以很容易推出：当 `N` 越小时，`N<x` 的几率越大。

额外的我们可以发现 `dp` 数组是一个关于 `i` 严格单调递增的。

> 反证法证明：因为如果 `dp[j] ≥ dp[i] 且 j < i `，那么 `dp[i]` 对应的递增子序列的第 `j` 个元素就应该小于 `dp[i]`，这与 `dp[j] ≥ d[i]`矛盾，这代表 **较短子序列的尾部元素的值 > 较长子序列的尾部元素的值**，这是不可能的。因此数组 `dp` 的单调性得证。

**优化方法：**

-   定义一个数组 `tails`，`tails[i]` 表示长度为 `i+1` 的最长递增子序列的末尾元素的最小值。

-   遍历数组 `nums`，对于每个 `nums[i]`，使用二分查找的方法，在 `tails` 中找到第一个大于 `nums[i]` 的元素 `tails[j]`，并更新 `tails[j]` 为 `nums[i]`。
-   遍历 `tails`，找到 `tails` 中最大的元素，即为最长递增子序列的长度。

##### 1.定义动态数组的含义

`tails[i]` 表示长度为 `i+1` 的递增子序列的末尾元素的最小值。

##### 2.状态移动方程

设 `res` 为 `tails` 的当前长度，代表直到当前的最长递增子序列长度。

根据题意，我们很容易得到状态转移方程：

设 `j∈[0, res)`，考虑每轮遍历 `nums[i]` 时，可以通过二分法遍历 `[0, res)`，找出 `nums[i]` 的大小分界点，并做以下判断：

-   区间中存在点 `j` 满足 `tails[j] > nums[i]`：将第一个满足 `tails[j] > nums[i]` 的下标 `j` 的值改为 `nums[i]`，即 `tails[j] = nums[i]`。

-   区间中不存在点 `j` 满足 `tails[j] > nums[i]`：意味着 `nums[i]` 可以接在前面所有长度的子序列之后，即`tails[res+1] = nums[i]`。

综上所属，我们需要计算出 `tails` 中满足值大于` nums[i]` 的元素下标 `j`，每轮执行 `tails[j] = nums[i]`，即：

-   如果 `tails` 中所有元素都小于 `nums[i]`，将其插入到最后面
-   否则，用它覆盖掉比它大的元素中最小的那个。

##### 3.返回值

最终答案为：`tails` 数组的长度，即为全局的最长递增子序列的长度。

##### 4.初始化状态数组

因为每个元素都至少可以单独成为子序列，所以起始时设置 `tails[0] = nums[0]`，表示长度为 `1` 的递增子序列的末尾元素的最小值为数组首个元素。

##### 代码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
    const n = nums.length;

    // 创建一个数组 tails 来存储当前递增子序列的尾部元素。 tails 未必是真实的最长上升子序列，但长度是当前最长递增子序列的长度。
    const tails = [nums[0]];

    // 遍历数组，查看当前子串可构建成的最长递增子序列。
    for (let i = 1; i < n; i++) {
        let left = 0;
        right = tails.length;

        // 二分法查找当前元素应该插入的位置
        while (left < right) {
            const mid = left + ((right - left) >> 1);
            if (tails[mid] < nums[i])
                left = mid + 1; // 如果当前元素大于 tails[mid]，则向右查找
            else right = mid; // 向左查找
        }

        // 此时有left = right，区间缩为一个点，即为 nums[i] 需要插入的位置，将当前元素插入到相应位置
        tails[left] = nums[i];
    }

    // 返回 nums 数组的最长递增子序列，即 tails 数组的长度。
    return tails.length;
};
```

-   时间复杂度：O($nlogn$)，n 为数组 nums 的长度，我们需要遍历一次数组，对于遍历到的每个元素都需要使用二分搜索进行一次状态更新，因此总的时间复杂度为 O($nlogn$)。
-   空间复杂度：O($n$)，n 为数组 nums 的长度。用于 tails 的空间开销，最差情况是原数组就是一个递增的序列，tails 的长度为原数组的长度。

> tips：这个算法按分类的话，算 「贪心+二分」。
> 其贪心策略为：
> 如果我们要使递增子序列尽可能的长，则我们需要让序列递增得尽可能慢，因此我们希望每次在递增子序列最后加上的那个数尽可能的小。
