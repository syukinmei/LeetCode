# 300.最长递增子序列（中等）

[最长递增子序列(中等)](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

<br/>

> 示例 1:
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

<br/>

> 示例 2:
> 输入：nums = [0,1,0,3,2,3]
> 输出：4

<br/>

> 示例 3:
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1

<br/>

提示：

-   1 <= nums.length <= 2500
-   -$10^4$ <= nums.length <= $10^4$

## 方法一：动态规划

根据题意分析，如果一个较大的数字接在较小数字的后面，就会形成一个更长的子序列。因此，只要 `nums[i]` 严格大于在它位置之前的某个数，那么 `nums[i]` 就可以接在这个数字后面形成一个更长的递增子序列。

##### 1.定义状态数字的含义

`dp[i]` 表示 `nums` 以 `nums[i]` 作为结尾时，最长递增子序列的长度。

##### 2.状态移动方程

根据题意，我们很容易得到状态转移方程：
设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，做以下判断：

-   如果 `nums[i] > nums[j]` ，那么 `nums[i]` 可以接在 `nums[j]` 后面，`dp[i] = max(dp[i], dp[j] + 1)` 。

-   如果 `nums[i] <= nums[j]` ，那么 `nums[i]` 不能接在 `nums[j]` 后面，`dp[i] = dp[i]` 。

综上所属，我们需要计算出 `dp[i]` 的最大值需要遍历 `j`，每轮执行 `dp[i] = max(dp[i], dp[j] + 1)`

> **dp[i] = Math.max(dp[i], dp[j] + 1) for j of [0, i)**

##### 3.返回值

最后一个状态值只表示以 `nums[len - 1]` 结尾的最长递增子序列的长度，状态数组 `dp` 的最大值才是全局的最长递增子序列的长度。

因此，最终答案为：dp 数组最大值 `max(...dp)`，即为全局的最长递增子序列的长度。

##### 4.初始化状态数组

`dp[i]` 所有元素置 `1`，含义是每个元素都至少可以单独成为子序列，此时长度都为 `1`。

##### 代码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
    const n = nums.length;
    // step1：定义并初始化状态转移方程
    // 创建 dp 数组，dp[i] 表示以 nums[i] 作为结尾时，最长递增子序列的长度。
    const dp = new Array(n).fill(1);

    // step2：状态推移
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            // 寻找新的递增子序列的头，并更新 dp[i] 。
            if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

    // step3：返回答案，max(...dp) 即为数组 nums 的最长递增子序列的长度
    return Math.max(...dp);
};
```

-   时间复杂度：O($n^2$)，n 为数组 nums 的长度，动态规划的时间 = 状态个数 \* 单个状态的计算时间。本题状态个数为 O(n)，对于每个状态需要遍历 dp[0...i-1] 的所有状态，因此单个状态的计算时间为 O(n)，总的时间复杂度为 O($n^2$)。
-   空间复杂度：O($n$)，n 为数组 nums 的长度。需要使用长度为 n 数组 dp 来存放状态规划状态个数。

> tips：遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。
