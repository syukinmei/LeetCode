// 给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。
// 如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。

// 输入：n = 22
// 输出：2
// 解释：22 的二进制是 "10110" 。
// 在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
// 第一对相邻的 1 中，两个 1 之间的距离为 2 。
// 第二对相邻的 1 中，两个 1 之间的距离为 1 。
// 答案取两个距离之中最大的，也就是 2 。

// 输入：n = 8
// 输出：0
// 解释：8 的二进制是 "1000" 。
// 在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。

// 输入：n = 5
// 输出：2
// 解释：5 的二进制是 "101" 。


/**
 * @param {number} n
 * @return {number}
 */
// 思路：使用一个循环从 n 二进制表示的最低位开始进行遍历，并找出所有的 1 。使用一个变量 pre 记录上一个找到的 1 的位置。如果当前在第 i 位置找到了 1，那么就用 i - pre 更新答案，再将 pre 更新为 i 即可。
// 1、使用位运算 n & 1 获取 n 的最低位
// 2、之后我们将 n 右移一位: n = n >> 1，这样在第 i 步时，n & 1 得到的就是初始 n 的第 i 个二进制位。
var binaryGap = function (n) {
    // pre 记录上一个 1 的位置。为 -1 时表示未出现 1 。
    let pre = -1, max = 0;

    for (let i = 0; n != 0; i++) {
        if (n & 1 === 1) {
            if (pre !== -1) {
                max = Math.max(max, i - pre);
            }
            pre = i;
        }
        n = n >> 1;
    }

    return max;
};
// 时间复杂度：O(logn)，循环中每一步都会将 n 右移一位，使得 n 减少一半，因此需要O(logn)次循环。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
