// 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
// 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

// 输入：nums = [1,2,1,3,2,5]
// 输出：[3,5]
// 解释：[5, 3] 也是有效的答案。

// 输入：nums = [-1,0]
// 输出：[-1,0]

// 输入：nums = [0,1]
// 输出：[1,0]

// 方法一：哈希表
// 我们可以使用一个哈希表统计数组中每一个元素出现的次数。
// 然后遍历哈希表，找到只出现一次的元素，并将其放入答案中。
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
    // 构建哈希表
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    // 找出只出现一次的元素
    const ans = [];
    for (const [num, occ] of freq.entries()) {
        if (occ === 1) {
            ans.push(num);
        }
    }
    return ans;
};

// 时间复杂度：O(n)，n 为整数数组 nums 的长度，构建哈希表需要 O(n) 的时间，遍历哈希表找出只出现一次的元素需要 O(n) 的时间，因此总的时间复杂度为 O(n)。
// 空间复杂度：O(n)，即为哈希表需要使用的空间。

// 方法二：位运算
// 我们可以使用位运算中的异或运算来解决这个问题。假设这两个数字分别为 x1 和 x2。
// 任何数异或它自己都等于 0，而数组 nums 有两个元素只出现一次，其余所有元素均出现两次，因此，对数组中所有元素进行异或和运算，得到的结果就是两个只出现一次的元素异或的结果。
// 假设这两个数字分别为 x1 和 x2。由于这两个数字只出现一次，所以 x1 !== x2，所以在异或和中必然有一个二进制位的值是1。
// 假设这个二进制位是第 i 位，那么 x1 和 x2 的第 i 位必然是不同的。其中一个数的二进制数的第 i 位为 1，另一个数的二进制数的第 i 位为 0。只有在这种情况下 x1 ⊕ x2 的二进制数的第 i 位才能是 1。
// 这时候我们把 nums 中的所有元素分成 2 组，分别是 二进制数的第 i 位为 1 的组和第 i 位为 0 的组。可以发现：
//  - 对于任意一个在数组 nums 中出现 2 次的元素，该元素的 2 次出现会被分配在同一组中。这是因为异或运算符的性质。
//  - 对于任意一个在数组 nums 中只出现 1 次的元素，即 x1 和 x2，它们会被分配在不同的组中。这是因为异或运算符的性质加上题目的限制。
// 此时，我们将每一组的元素全部异或起来，那么其中一组就会得到 x1，另一类会得到 x2。

// 具体的实现：
// 异或所有数字：将所有数字进行异或和操作，得到的结果是两个只出现一次的数字的异或结果 xorResult。
// 找到最低有效位：利用补码特性 xorResult & -xorResult 快速找到 xorResult 最低为 1 的位。
// 分组并异或：根据最低有效位，将数组中的数字分成两组，每组分别进行异或操作，最终每组会得到一个只出现一次的数字。

/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function (nums) {
    // step1：异或所有数字，得到两个只出现一次的数字的异或结果
    let xorResult = 0;
    for (const num of nums) {
        xorResult ^= num;
    }

    // step2：利用补码找到 xorResult 中最低为1的位
    const i = xorResult & -xorResult;

    // step3：根据最低有效位将数字分成两组并分别异或
    let group1 = 0,
        group2 = 0;
    for (const num of nums) {
        if ((num & i) !== 0) group1 ^= num;
        else group2 ^= num;
    }

    return [group1, group2];
};
// 时间复杂度：O(n)，n 为整数数组 nums 的长度，
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
