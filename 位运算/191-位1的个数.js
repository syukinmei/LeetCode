// 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。


// 输入：00000000000000000000000000001011
// 输出：3
// 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

// 输入：00000000000000000000000010000000
// 输出：1
// 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

// 输入：11111111111111111111111111111101
// 输出：31
// 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


/**
 * @param {number} n - a positive integer
 * @return {number}
 */
// 方法一：循环检查二进制位
// 循环检查 n 的二进制位的每一位是否为1，当检查第 i 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为0。
var hammingWeight = function (n) {
    let count = 0;
    for (let i = 0; i < 32; i++) {
        if ((n & (1 << i)) !== 0) count++;
    }
    return count;
};
// 时间复杂度：O(k)，k 是 int 型的二进制位数，k = 32 。我们需要检查 n 的二进制位的每一位，一共需要检查 32 位。
// 空间负载的：O(1)，只需要常数的空间存放若干变量。

// 方法二：位运算
// 使用 按位与 n & 1 判断二进制数n末尾是否为1，然后将n右移一位，直至结束。
// 注意此处有坑。
// 如果使用算术右移 >> 则会导致超时。这是因为：
//  - 算术右移 >>  ：舍弃最低位，最高位用符号位填补。
//  - 逻辑右移 >>> ：舍弃最低位，高位用 0 填补。
// 那么对于负数而言，其二进制最高位是 1，如果使用算术右移 >>，那么最高位填补的仍然是 1。也就是 n 永远不会为0，就会导致代码超市 TLE。
var hammingWeight = function (n) {
    let count = 0;
    while (n) {
        count += n & 1;
        n >>>= 1;
    }
    return count;
};
// 时间复杂度：O(k)，k 为 n 的二进制长度。我们需要检查 n 的二进制位的每一位。
// 空间负载的：O(1)，只需要常数的空间存放若干变量。

// 方法三：位运算优化（消除二进制末尾的1）
// 观察这个运算：n & (n - 1)，其运算结果恰为把 n 的二进制位中的最低的 1 变为 0 之后的结果。
// 如：6 & (6 - 1) = 4，6 = (110)_2，4 = (100)_2。
// 我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让 n 与 n-1 做与运算，直到 n变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制中 1 的个数。
var hammingWeight = function (n) {
    let count = 0;
    while (n) {
        n &= n - 1;
        count++;
    }
    return count;
};
// 时间复杂度：O(n)，循环次数等于 n 的二进制位中 1 的个数。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
