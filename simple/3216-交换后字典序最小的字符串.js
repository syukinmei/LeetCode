// 给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。
// 如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。

// 输入： s = "45320"
// 输出： "43520"
// 解释：
// s[1] == '5' 和 s[2] == '3' 都具有相同的奇偶性，交换它们可以得到字典序最小的字符串。

// 输入： s = "001"
// 输出： "001"
// 解释：
// 无需进行交换，因为 s 已经是字典序最小的。

// 方法一：模拟
// 看到题目，我们初步能想到的是，尝试所有满足约束的可能交换，并维护按字典顺序最小的字符串。

// 但是由于题目限制最多交换一次相邻字符，因此交换的位置越靠前（左）越好，例如示例 1 的 45320，交换 5 和 3 得到 43520，而交换更靠右的 2 和 0 得到 45302，这比 43520 大。
// 这是因为两个字符串长度相同，则拥有首个不同字符中较小那个的字符串字典序更小。
// 因此，我们逻辑是返回第一对可交换，且左边数字大于右边数字的交换后字符串，否则表示没有找到可以交换的数字对，原字符串已经是字典序最小的字符串了，返回原字符串即可。
// 代码实现：
//  - 遍历字符串 [0, n-2]
//  - 找到首个满足交换条件的下标 i，即 nums[i] 和 nums[i+1] 的奇偶性相同，且 nums[i] > nums[i+1]。
//  - 遍历结束，没有执行交换，返回原字符串

// 额外的，字符对应的数字的奇偶性，等于字符的 ASCII 值的奇偶性。
