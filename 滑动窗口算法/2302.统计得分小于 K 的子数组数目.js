// 一个数组的 分数 定义为数组之和 乘以 数组的长度。

// 比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。
// 给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 严格小于 k 的 非空整数子数组数目。

// 子数组 是数组中的一个连续元素序列。

// 示例 1：
// 输入：nums = [2,1,4,3,5], k = 10
// 输出：6
// 解释：
// 有 6 个子数组的分数小于 10 ：
// - [2] 分数为 2 * 1 = 2 。
// - [1] 分数为 1 * 1 = 1 。
// - [4] 分数为 4 * 1 = 4 。
// - [3] 分数为 3 * 1 = 3 。
// - [5] 分数为 5 * 1 = 5 。
// - [2,1] 分数为 (2 + 1) * 2 = 6 。
// 注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。

// 示例 2：
// 输入：nums = [1,1,1], k = 5
// 输出：5
// 解释：
// 除了 [1,1,1] 以外每个子数组分数都小于 5 。
// [1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。
// 所以总共有 5 个子数组得分小于 5 。

// 方法一：滑动窗口
// 根据题目对数组分数的定义，以及 nums 是正整数数组这一特性，可得，对于子数组 [i, j] ，当右端点 j 固定时，随着左端点 i 的增加，子数组的和会减少，长度也会缩短，因此子数组的分数会呈现单调递减的特性。
// 如果子数组 [i, j] 的分数小于 k ，由于分数单调递减，那么子数组 [p, j] (其中 i < p <= j) 的分数也一定小于 k 。
// 根据这一特性，我们可以使用滑动窗口来解决这个问题。

// 具体的：
// 我们从左到右遍历数组 nums ，使用变量 i 表示滑动窗口的左端点，变量 j 表示滑动窗口的右端点，初始时 i 和 j 都指向下标 0 。
// 我们依次遍历数组 nums 中的每个元素，同时维护一个变量 sum 表示滑动窗口中所有元素的和，进行如下操作：
// 拓展窗口，将 nums[j] 加到滑动窗口中，并更新窗口元素和 sum。
// 判断窗口中对应的子数组分数 sum * (j - i + 1) 是否大于等于 k。
//  - 如果大于说明子数组不符合要求，需要缩小窗口，向右移动左端点 i ，直到 sum * (j - i + 1) < k 为止。在移动左端点 i 的过程中，我们需要将窗口元素和 sum 减去 nums[i] 。
//  - 如果小于说明子数组符合要求，将子数组的个数增加 j - i + 1 。
// 重复上述步骤，直到 j 遍历完数组 nums 中的每个元素。

// 时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们最多遍历数组 nums 两次。
// 空间复杂度：O(1)，只需要常数的空间存放若干变量。
