// 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

// 输入：num = "1432219", k = 3
// 输出："1219"
// 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。

// 输入：num = "10200", k = 1
// 输出："200"
// 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

// 输入：num = "10", k = 2
// 输出："0"
// 解释：从原数字移除所有的数字，剩余为空就是 0 。


/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */

// 提示：对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 A = 1axxx，B = 1bxxx，如果 a > b 则 A > B。
// 基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。

// 方法一：单调栈 删除数组高位的大数

// 从左到右遍历num数组，维护一个单调递增的栈，但遇到当前元素小于栈顶的元素时，进行弹栈，因为，栈顶的数在高位，删掉它，小的顶上，高位变小，整个数变小。
// 特殊情况：
// - 如果我们删除了 m 个数字且 m < k，这种情况下我们需要从序列尾部删除额外的 k−m 个数字
// - 如果最终的数字序列存在前导零，我们要删去前导零
// - 如果最终数字序列为空，我们应该返回 '0'
var removeKdigits = function (num, k) {
    const stack = []; // 单调递增栈
    for (let i = 0; i < num.length; i++) {
        // 栈中有值 且 当前元素 大于 栈顶元素 弹栈（弹栈元素不得超过k个）
        while (k > 0 && stack.length && num[i] < stack[stack.length - 1]) {
            stack.pop(); // 栈顶元素为位于高位的大数，应删除小树顶上
            k--; // 记录删除个数
        }
        stack.push(num[i]);
    }
    for (; k > 0; k--) {
        stack.pop();
    }
    // 处理结果
    // 栈中无值，返回 0
    // 栈底元素为0，将其删除
    while (stack.length && stack[0] === '0') {
        stack.shift();
    }

    return stack.length ? stack.join('') : '0';
}
// 时间复杂度：O(n)，其中 n 为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k 次。由于 0 < k ≤ n，主循环的时间复杂度被限制在 2n 以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为 O(n)。
// 空间复杂度：O(n)，栈存储数字需要线性的空间。